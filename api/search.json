[{"id":"72468961c9322689b5ba89f282674665","title":"51单片机数码管","content":"数码管数码管在开发板的左上角位置，是一种简单廉价的显示器，由多个发光二极管封装在一起组成的“8”字型器件\n数码管分为共阳极和共阴极类型\n根据开发板原理图如下\n\n数码管和138译码器是联动使用的，根据原理图可知，138译码器的P2_4、P2_3、P2_2组成的CBA二进制数，输出端对应的LED控制着点亮数码管的位置，数码管所显示的信息有0、1、2、3、4、5、6、7、8、9，根据原理图可得下表\n\n\n\n数码管显示\n十六进制代码\n\n\n\n0\n0x3F\n\n\n1\n0x06\n\n\n2\n0x5B\n\n\n3\n0x4F\n\n\n4\n0x66\n\n\n5\n0x6D\n\n\n6\n0x7D\n\n\n7\n0x07\n\n\n8\n0x7F\n\n\n9\n0x6F\n\n\n这里我们可以构造一个便捷使用数码管的函数\ncunsigned char NixieTable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;;\nvoid Nixie(unsigned char Location,Number)\n&#123;\n    switch(Location)\n    &#123;\n            case 1:P2_4=1;P2_3=1;P2_2=1;break;//千万不要忘记break\n            case 2:P2_4=1;P2_3=1;P2_2=0;break;\n            case 3:P2_4=1;P2_3=0;P2_2=1;break;\n            case 4:P2_4=1;P2_3=0;P2_2=0;break;\n            case 5:P2_4=0;P2_3=1;P2_2=1;break;\n            case 6:P2_4=0;P2_3=1;P2_2=0;break;\n            case 7:P2_4=0;P2_3=0;P2_2=1;break;\n            case 8:P2_4=0;P2_3=0;P2_2=0;break;\n    &#125;\n    P0=NixieTable[Number];\n&#125;\n    ","slug":"51单片机数码管","date":"2024-02-02T16:09:03.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"b47f8004de5de2e7f095c07f5432799b","title":"51单片机独立按键模块","content":"51单片机的独立按键模块这篇文章我们来学习51单片机开发板的独立按键模块\n根据开发板原理图，独立按键模块的接口如下图所示\n\n\n如图所示，四个独立按键都是检测低电平，且K1由P3_1控制，K2由P3_0控制，K3、K4由P3_2、P3_3控制\n按键的抖动对于机械开关，机械触点断开闭合时，由于机械开关触点的弹性作用，一个开关在闭合的时候不会马上稳定的接通，在断开的时候也不会一下子就断开，在闭合和断开的那一瞬间会伴随一连串的抖动\n\n\n对于按键抖动，一般有两种方法可以消除，一种是硬件消抖，通过按键输出通道上添加去抖动电路（如单稳态电路或者滤波电路等（详情见模拟电路））从根本上避免抖动发生，但是由于增加了硬件电路，会增加一定的成本和电路的复杂程度。还有一种最常用的消抖方法是软件消抖，在检测到按键按下时，延迟一定的时间（5-10毫秒甚至20毫秒）等抖动期过去后重新检测按键的状态，如果在延迟期间按键保持闭合状态，则认为是有效的按键按下，如果不是，则有可能是一个抖动的干扰信号，按键的释放过程也类似，检测到按键松开时，延迟一定时间（5-10毫秒）等抖动期过去后结束。\ncvoid main()  //这里我们只给出主函数，延时函数等模块的代码自行添加\n&#123;\n    while(1)\n    &#123;\n        if(P3_1==0)//判断K1按下\n        &#123;\n            Delay(20);//延时20ms过滤掉抖动\n            while(P3_1==0);//如果按键一直按下，会在这个循环里一直循环，松手后会跳出循环\n            Delay(20);//过滤掉松手后的抖动\n        &#125;\n    &#125;\n&#125;独立按键使用示例独立按键其实是一个非常简单的模块，主要是在编写程序的时候会用到大量的IF语句，比较考验编程者的逻辑思维能力，下面给出一段调用独立按键模块的示例代码和注释，方便大家学习\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()\n&#123;\n    while(1)\n    &#123;\n        if(P3_1==0)//判断K1按下\n        &#123;\n            Delay(20);//延时20ms过滤掉抖动\n            while(P3_1==0);//如果按键一直按下，会在这个循环里一直循环，松手后会跳出循环\n            Delay(20);//过滤掉松手后的抖动\n             P2=~P2;//松手后LED模块会全部亮起或者全部熄灭\n        &#125;\n    &#125;\n&#125;","slug":"51单片机独立按键模块","date":"2024-02-02T14:37:25.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"0e7c93a805541486cdd5b2caca119a40","title":"51单片机常用模块驱动代码","content":"51单片机常用模块驱动代码延时代码Delay()在STC-ISP中，我们可以根据自己开发板的型号和系统的频率来自动生成对应时间的延时代码，需要多长时间我们就选择对应的定时长度。\n\n\n但是生成的延时代码只能对应一个延时时间，所以我们需要自己构造一个函数，来延时我们想要延时的时间，我们可观察到的时间单位一般是以秒或者毫秒为单位的，如果是以微秒为的单位，开发板的变化可能以肉眼观察不到，所以我们自动生成一个一毫秒的延时代码，将自动生成的代码复制到Keil中\n\n\n已知根据开发板的配置生成的一毫秒的延时函数，即一次这样的do-while循环会延时1毫秒，所以我们在里面构造一个while函数，定义一个xms形参，来定义我们想要延时的毫秒数，修改后的Delay函数如下\ncvoid Delay(unsigned char xms)\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;这样，在开发板程序中，一个Delay（xms）函数就相当于延时了xms毫秒\n下面是一个使用示例\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned char xms)\t//@12.000MHz\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()\n&#123;\n    while(1)\n    &#123;\n        P2_0=~P2_0;\n        Delay(500);\n    &#125;\n&#125;这段代码的实现功能是让开发板上LED模块的D1灯以500ms的频率闪烁\n","slug":"51单片机常用模块驱动代码","date":"2024-02-02T09:45:18.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"455781cc215699651b5e7dac0955faf1","title":"使用51单片机控制LED模块","content":"用51单片机控制单片机上的LEDLED介绍：\n\n中文名：发光二极管\n英文名：Light Emitting Diode\n简称LED\n用途：照明、广告灯、指引灯、屏幕\n\n\n\n由开发板原理图我们可以知道，开发板上的LED模块（D1到D8八个横向的LED灯）是由MCU主板上的P20~P27八个引脚控制，我们可以在Keil工程中编程控制\n且8个LED是由低电平控制，即引脚0为亮，1为灭\n整体控制以下代码控制八个LED灯全亮\nc#include &lt;REGX52.H&gt;\n\nvoid main()\n&#123;\n    P2=0x00;  // 0000 0000\n    while(1)\n    &#123;\n        \n    &#125;\n&#125;注意，控制P2的八个引脚，P27~P20，可以用P2表示一个八位的二进制数，即两位十六进制数，如以上代码\n一般的单片机程序都会在主程序后面加上while(1)的死循环,指代码不再向下执行，主要是为了防止程序跑飞，让程序一直保持在我们需要的情况下。\n\n由于C语言不能直接表示二进制数，我们一般通过十六进制或者十进制来表示P2端口的状态,P20到P27依次控制D1到D8,\n单独控制我们也可以用P2_0,P2_1,P2_2,P2_3……P2_7来单独控制各个LED灯的状态\nc#include &lt;REGX52.H&gt;\n\nvoid main()\n&#123;\n    P2_0=0;\n    P2_1=1;\n    P2_2=0;\n    P2_3=1;\n    P2_4=0;\n    P2_5=1;\n    P2_6=0;\n    P2_7=1;\n    \n    while(1)\n    &#123;\n        \n    &#125;\n&#125;控制LED闪烁效果为了控制LED闪烁，我们需要用到延时函数，有关延时函数的介绍我们放到另一篇文章：51单片机常用模块的驱动代码讲解。\n一下是示例代码和注释\nc#include &lt;REGX52.H&gt;\n\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\n\nvoid main()  //主函数\n&#123;\n    \n    while(1)\n    &#123;\n        P2_1=0; //LED灯D2亮\n        Delay(500); //延时500ms\n        P2_1=1;\t//LED灯D2灭  \n        Delay(500);  //延时500ms\n    &#125;\n&#125;这段代码实现了D2灯的闪烁，当然调整延时时间也可以控制闪烁的频率\n实现流水灯效果的几种方法最简单的暴力写法第一种方法毫无技术性可言，就是对每个灯的接口挨个编写，但是这种方法写起来既费时又费力，不建议大家写程序时使用这种写法。但是初学者还是从这种写法开始写起：我们直接看下列代码\nc#include &lt;REGX52.H&gt;\n\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\n\nvoid main()  //主函数\n&#123;\n    \n    while(1)\n    &#123;\n        P2_0=0;\n        Delay(500);\n        P2_0=1;\n        P2_1=0;\n        Delay(500);\n        P2_1=1;\n        P2_2=0;\n        Delay(500);\n        P2_2=1;\n        P2_3=0;\n        Delay(500);\n        P2_3=1;\n        P2_4=0;\n        Delay(500);\n        P2_4=1;\n        P2_5=0;\n        Delay(500);\n        P2_5=1;\n        P2_6=0;\n        Delay(500);\n        P2_6=1;\n        P2_7=0;\n        Delay(500);\n        P2_7=1;\n    &#125;\n&#125;个人不是很建议在实际应用中使用这种写法。\n移位法为了实现流水灯效果，就是让P2接口的赋值的二进制数11111110当中的0从右向左或者从左向右依次移位，这里我们可以用到位运算符&lt;&lt;或者&gt;&gt;联合循环语句实现\n\n\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()  //主函数\n&#123;\n    char temp = 0x01;//创建一个临时变量temp\n    while(1)\n    &#123;\n        if(!temp)temp = 0x01;//判断临时变量的状态，如果临时变量为0了，把他重新赋值为0000 0001\n        P2=~temp; //让P2对temp取反，即P2= 1111 1110\n        Delay(500);//延时500ms\n        temp=temp&lt;&lt;1;//temp向左移位，例如第一次移位后temp为0000 0010，P2为1111 1101\n    &#125;\n&#125;权表示法让LED模块实现流水灯效果，就是让P2的值依次移位，像上一个方法一样，P2&#x3D;1111 1110——-1111 1101——–1111 1011——–1111 0111&amp;…………0111 1111,这是二进制数的变换，我们把他按权展开，如下图所示\n\n\nc#include &lt;REGX52.H&gt;\n#include &lt;math.h&gt;//调用数学函数，为了使用2的n次方\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()  //主函数\n&#123;\n    int i=0;\n    while(1)\n    &#123;\n        for(i=0;i&lt;8;i++)\n        &#123;\n            P2=255-pow(2,i);\n            Delay(500);\n        &#125;\n    &#125;\n&#125;代码的逻辑思维展现在刚刚上面的流程图上，可以理解一下上面的流程图再编写代码\n结语以上就是51单片机中LED灯的基本控制方法，其实LED灯还可以联合51单片机的其他模块，如矩阵键盘、独立键盘、数码管等模块，期待在今后的学习中能够不断探索这些模块之间的应用。\n","slug":"使用51单片机控制LED模块","date":"2024-02-02T09:37:36.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"63c2215d1bf95a785134886f25737c76","title":"AltiumDesigner入门","content":"Altium Designer入门本片文章的学习方向：\n\nAD软件\n电子设计\n原理图\n原理图库\n原理图绘制\n\n\nPCB设计\nPCB布局\nPCB布线\n\n\n\n\n\n学习方法：\n\n软件\n软件操作多练习\n牢记快捷键\n\n\n设计1.##软件中英文切换打开软件后，软件激活：可以在网络上搜所AltiumDesigner学生权益，通过学校邮箱注册学生版本，当然，没有学校邮箱的也可以选择网络上的激活方法进行激活由于刚安装软件，菜单全部都是英文状态，这个时候我们可以打开菜单栏右上角的设置图标，进入设置页面后在勾选使用本地资源，然后重新启动软件，这个时候我们可以看到整个界面都成为中文界面了\n\nAD工程的组成和创建一个PCB工程包含了原理图库、原理图、PCB库、PCB、生产文件等。以下演示创建一个PCB工程的操作首先创建一个项目在界面中选一个默认的PCB的demo，起一个合适的名字和选择合适路径后生成然后创建我们的PCB元件库和原理图库、原理图（有些版本可能会自动生成） 我们的工程就包含了一下四个文件：\n元件库及电阻容模型的创建","slug":"AltiumDesigner入门","date":"2024-01-29T15:31:08.000Z","categories_index":"电子设计","tags_index":"电子","author_index":"Ed-RYan"},{"id":"4171019def9ad8410a9c1f9275586e43","title":"51单片机基础","content":"51单片机基础单片机介绍：\n\n单片机：简称MCU\n内部集成了CPU，RAM，ROM，定时器，中断系统，通讯结构等一系列电脑常用的硬件功能\n单片机依靠传感器信息采集，依靠CPU处理信息，硬件设备等\n单片机相当于一个袖珍版计算机，一个芯片可以构成完整的计算机系统，但是在性能上相差甚远。\n\nSTC89C52单片机\n\n所属系列：51单片机系列\n公司：STC单机（中国的）\n位数：8位\nRAM：512字节（512B）\nROM：8K（Flash）\n工作频率：12MHz\n\n为什么叫51单片机？\n​\t原因是80年代Intel开发的8051单片机内核的统称，凡是与“8051”内核一样的单片机都称为51系列单片机\n单片机命名规则：\n例：STC89C52\n\n\nSTC：公司\n89：系列\nC：工作电压\nC：5.5V~3.8V\nLE：3.6V2.4V&#x2F;3.4V2.4V\n\n\n52：程序空间及RAM空间大小\n\n\n\n35：工作频率（可达到35MHz）\nI：工业温度范围\nI：工业级：-40℃~80℃\nC：商业级：0℃~70℃\n\n\nDIP40：封装类型\n40：管脚数\n\n详情见STC89C52手册\n\n","slug":"51单片机基础","date":"2024-01-26T15:30:39.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"96563376ad7b138d66798614753928b1","title":"Java数据结构和算法","content":"Java 数据结构和算法数据结构和算法的重要性：\n\n算法是程序的灵魂，程序在进行海量的数据计算时，优秀的算法可以让程序保持高速运算\n程序会使用 内存计算框架 和 缓存技术 来优化程序\n\n数据结构和算法的关系\n\n数据（data）结构（structure）是研究组织数据方式的学科\n程序 &#x3D; 数据结构＋算法\n数据结构是算法的基础\n\n数据结构包括：线性结构 和 非线性结构线性结构\n线性结构是最常用的数据结构，特点是数据元素之间存在一对一的线性关系\n线性结构有两种不同的存储结构，即 顺序存储结构 和 链式存储结构。\n顺序存储方式即为顺序表，顺序表中存储元素是连续的（地址是连续的，如 数组）\n链式存储方式的线性表称为 链表，链表中存储元素不一定是连续的，元素节点中存放数据元素和相邻元素的地址信息。\n线性结构常见的有：数组、队列、链表、栈\n\n非线性结构\n非线性结构包括：二维数组、多维数组、广义表、树结构、图结构\n\n稀疏数组和队列稀疏数组（sparsearray 数组）二维数组默认值为 0，有时候使用二维数组会有大部分元素为 0，即有很多无用数据，这个时候可以使用稀疏数组。\n定义：当一个数组大部分元素为 0，或为同一个值的数组，可以使用稀疏数组来保存该数组。\n处理方法\n\n记录 数组有几行几列，有多少不同数值\n把记录不同数值的元素的行列值存储在另一个小规模数组中，从而 缩小程序规模。\n\n \n这里拓展数组的定义和遍历方式\n定义方式：\njavaint Arr1[]=new int [5];//定义普通一维数组(静态初始化)\n//也可以直接赋值(动态初始化)\nint Arr2[]=&#123;1,2,3,4,5&#125;;\n//以下是二维数组定义\nint Arr3[][]=new int[3][4];\nint Arr4[3][4]=&lt;!--swig￼0--&gt;;常用遍历方式：\njavafor(int i=0;i&lt;Arr2.length;i++)&#123;\n    System.out.print(Arr2[i]+&quot;\\t&quot;);\n&#125;//一位数组遍历\nfor(int i=0;i&lt;Arr3.length;i++)&#123;\n    for(int j=0;j&lt;Arr3[i].length;j++)&#123;\n        System.out.print(Arr3[i][j]+&quot;\\t&quot;);\n    &#125;\n    System.out.println();\n&#125;//二维数组遍历增强遍历方式（foreach 遍历）\njavafor(int num:Arr2)&#123;\n    System.out.println(num+&quot;\\t&quot;);\n&#125;//一维数组的 foreach 遍历\nfor(int[]row:Arr4)&#123;\n    for(int data:row)&#123;\n        System.out.print(data+&quot;\\t&quot;)\n    &#125;\n&#125;拓展完数组的定义和遍历方式，我们接下来用代码实现稀疏数组和原始数组的转换：\njavapublic class SparseArry&#123;\n    public static void main(String[] args)&#123;\n        //首先创建一个原始的数组\n        int Arr1[][]=new int [10][10];\n        Arr1[3][4]=1;\n        Arr1[5][6]=2;\n        Arr1[2][5]=3;\n        //遍历二维数组(走个形式)\n        System.out.println(&quot;遍历二维数组Arr1&quot;);\n        for(int []row:Arr1)&#123;\n            for(int data:row)&#123;\n                System.out.printf(&quot;%d\\t&quot;,data);\n            &#125;\n            System.out.println();//每遍历一行换行\n        &#125;\n        //ok, 接下来我们将原始二维数组转换为稀疏数组，第一步是得到非零元素的个数 sum\n        int sum=0;\n        for(int i=0;i&lt;Arr1.length;i++)&#123;\n            for(int j=0;j&lt;Arr1[i].length;j++)&#123;\n                if(Arr1[i][j]!=0)&#123;\n                    sum++;\n                &#125;\n            &#125;\n        &#125;\n        //有了非零元素的个数 sum 后，就可以创建稀疏数组了 sparseArr [sum+1][3] 了\n        int sparseArr[][]=new int [sum+1][3];\n        //第一行是稀疏数组的整体结构\n        sparseArr[0][0]=10;\n        sparseArr[0][1]=10;\n        sparseArr[0][2]=sum;\n        //接下来将非零值存放到数组中\n        int count=0;\n        for(int i=0;i&lt;10;i++)&#123;\n            for(int j=0;j&lt;10;j++)&#123;\n                if(Arr1[i][j]!=0)&#123;\n                    count++;\n                    sparseArr[count][0]=i;\n                    sparseArr[count][1]=j;\n                    sparseArr[count][2]=Arr1[i][j];\n                &#125;\n            &#125;\n        &#125;\n        //这个时候稀疏数组已经创建完成了，我们来遍历一下稀疏数组\n        System.out.println(&quot;常用遍历&quot;);\n        for(int i=0;i&lt;sparseArr.length;i++)&#123;\n            System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);\n        &#125;\n        System.out.println(&quot;foreach遍历&quot;);\n        for(int[]row:sparseArr)&#123;\n            for(int data:row)&#123;\n                System.out.print(data+&quot;\\t&quot;);\n            &#125;\n        &#125;\n        //有了稀疏数组，这个时候我们将稀疏数组转换为二维数组\n        //先读取第一行创建原始的二维数组\n        int Arr2[][] = new int [sparseArr[0][0]][sparseArr[0][1]];\n        System.out.println(&quot;输出恢复后的二维数组&quot;);\n        //从稀疏数组的第二行开始将非零元素代入原始二维数组\n        for(int i=1;i&lt;sparseArr.length;i++)&#123;\n            Arr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];\n        &#125;\n        //遍历一遍转换后的二维数组\n        for(int[]row:Arr2)&#123;\n            for(int data:row)&#123;\n                System.out.print(data+&quot;\\t&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;队列\n队列是一个有序列表，可以用 数组（顺序存储）或者 链表（链式存储）来实现\n遵循 先入先出 的原则\n\n数组模拟队列\n将数据存入队列：addQueue, addQueue 处理有两个步骤：\n思路分析\n当 front&#x3D;&#x3D;rear（空的）将尾指针往后移：rear+1\n若 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素，否则无法存入数据。rear&#x3D;&#x3D;maxSize-1（队列满）\n\n\n\n\n\n这里拓展一下构造器和异常的知识\n构造器也叫做构造方法、构造函数，在项目中使用频繁，每次 new 一个对象的时候就会调用构造器，构造器的格式如下：\n修饰符（private、default、protected、public）\t类名\t（参数列表（可以没有参数））{（不能有 return）}\n注意事项\n\n构造器的名称和类名一致\n一个类中可以有多个构造器，构造器的参数列表必须不同（重载：可以简单理解为：同个方法名，不同的参数列表。）\n如果没有手动定义构造器，Java 会提供一个默认构造器以供使用，一旦我们定义了构造器，系统会把默认构造器收回\n构造器的作用：实例化对象，给对象赋初始值\n\n定义、使用、继承、重载\njava//一下是一个定义构造器的例子\npublic class Fu&#123;\n    public Fu()&#123;&#125;//无参数的公有构造方法\n    public Fu(int i)&#123;&#125;//有参数的公有构造方法\n&#125;\n//创建 Fu 的一个子类 Demo\npublic class Demo extends Fu&#123;\n    public Demo()&#123;&#125;//无参数的公有构造方法\n    public Demo(int i)&#123;&#125;//有参数的公有构造方法\n&#125;\n//构造器的使用\npublic static void main(String[] args)&#123;\n    //使用方法 1：new 一个对象\n    Demo d1 = new Demo();\n    Demo d2 = new Demo(int i);\n&#125;\n//使用方法 2：在构造方法中使用 this 和 super 关键字，必须在构造方法的第一条语句，且不能同时存在\npublic Demo()&#123;\n  this(2); //这里调用参数为 int 类型的本类的构造方法，即调用了 Demo(2)\n &#125;\npublic Demo()&#123;\n  super(1); //调用参数为 int 类型的父类的构造方法, 即调用了 Fu(1)\n &#125; \n//构造器继承\n//子类构造器会默认调用父类无参构造器，如果父类没有无参构造器，则必须在子类构造器的第一行通过 super 关键字指定调用父类的哪个构造器\n//父类构造器\npublic class Father&#123;\n    //自定义带参构造器\n    public Father(String str)&#123;\n        System.out.println(&quot;父类的带参构造方法，参数为：&quot;+str);\n    &#125; \n&#125;\n//子类构造器\npublic class Son extends Father&#123;\n    //无参构造器\n    public Son()&#123;\n        //由于 Father()没有无参构造器，所以必须在子类型构造器中通过 super(&quot;字符串&quot;)来调用，否则编译器会报错。\n        //如果没定义这句，系统会默认调用 super()\n        super(&quot;&quot;);\n    &#125;\n    //带参构造器\n    public Son(String str)&#123;\n        //由于 Father()没有无参构造器，所以必须在子类型构造器中通过 super(&quot;字符串&quot;)来调用，否则编译器会报错。\n        //如果没定义这句，系统会默认调用 super()\n        super(str);      \n    &#125;  \n&#125;\n代码实现数组模拟队列：\njavapackage com.data.arrayQueue;\nimport java.util.Scanner;\n//使用数组模拟队列：编写一个类\nclass ArrayQueue&#123;\n  private int maxSize;//表示数组的最大容量\n  private int front;//指向队列头的前一个位置\n  private int rear;//指向队列尾\n  private int[] arr;//该数组用于存放数据: 模拟队列\n\n  //创建队列的构造器\n  public ArrayQueue(int arrMaxSize)&#123;\n      maxSize = arrMaxSize;\n      arr = new int[maxSize];\n      //front 和 rear 开始都是-1\n      front = -1;//队列头的前一个位置\n      rear = -1;//队列尾的数据\n  &#125;\n  //判断队列是否满\n  public boolean isFull()&#123;\n      return rear==maxSize-1;\n      //队列满时，rear = maxSize-1\n  &#125;\n  //判断队列是否空\n  public boolean isEmpty()&#123;\n      return rear==front;\n      //队列空时，rear = front\n  &#125;\n  //添加数据到队列\n  public void addQueue(int n)&#123;\n      //先判断队列是否满\n      if(isFull())&#123;\n          System.out.println(&quot;队列满，不能加入数据&quot;);\n          return;\n      &#125;\n      rear++;//队列未满，执行 rear 后移\n      arr[rear]=n;\n  &#125;\n  //获取队列的数据(数据出队列)\n  public int getQueue()&#123;\n      if(isEmpty())&#123;\n          //抛出异常\n          throw new RuntimeException(&quot;队列空，不能取出数据&quot;);\n      &#125;\n      front++;\n      return arr[front];\n  &#125;\n  //显示队列所有数据\n  public void showQueue()&#123;\n      //遍历数组\n      if(isEmpty())&#123;\n          System.out.println(&quot;队列空，无法遍历&quot;);\n          return;\n      &#125;\n      for(int i=0;i&lt;arr.length;i++)&#123;\n          System.out.printf(&quot;arr[%d]=%d\\n&quot;,i,arr[i]);\n      &#125;\n  &#125;\n  //显示队列的头数据，注意不是取出数据\n  public int headQueue()&#123;\n      if(isEmpty())&#123;\n          throw new RuntimeException(&quot;队列空，无头数据&quot;);\n      &#125;\n      return arr[front+1];\n  &#125;\n&#125;\npublic class ArrQueue&#123;\n  public static void main(String[] args)&#123;\n      //测试一下\n      //创建一个新队列\n      ArrayQueue queue = new ArrayQueue(3);\n      char key = &#39; &#39;;//接收用户输入\n      Scanner scanner =new Scanner(System.in);\n      boolean loop = true;//默认死循环\n      //输出一个菜单\n      while(loop)&#123;\n          System.out.println(&quot;s(show):显示队列&quot;);\n          System.out.println(&quot;e(exit):退出程序&quot;);\n          System.out.println(&quot;a(add):添加数据到队列&quot;);\n          System.out.println(&quot;g(get):从队列取出数据&quot;);\n          System.out.println(&quot;h(head):查看队列头的数据&quot;);\n          key = scanner.next().charAt(0);\n          switch(key)&#123;\n              case &#39;s&#39;:\n                  queue.showQueue();\n                  break;\n              case &#39;a&#39;:\n                  System.out.println(&quot;输出一个数&quot;);\n                  int value = scanner.nextInt();\n                  queue.addQueue(value);\n                  break;\n              case &#39;g&#39;:\n                  System.out.println(&quot;取出队列数据&quot;);\n                  try&#123;\n                      //因为从队列中取出数据会先判断队列是否为空，空队列时会抛出异常，这时候使用 java 的异常处理机制 try-catch 来处理\n\n                      int res = queue.getQueue();\n                      //如果 getQueue 抛出异常就会被下面的 catch 抓住\n                      System.out.printf(&quot;取出的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      //如果抛出异常，就输出 e 中的异常\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;h&#39;:\n                  System.out.println(&quot;查看队列头数据&quot;);\n                  try&#123;\n                      int res = queue.headQueue();\n                      System.out.printf(&quot;队列头的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;e&#39;:\n                  scanner.close();\n                  loop=false;\n                  break;\n              default:\n                  break;\n          &#125;\n          System.out.println(&quot;程序退出&quot;);\n      &#125;\n  &#125;\n&#125;\n以上是数组模拟队列的代码实现，但是这段代码是有问题的，数组使用一次就不能用了（没有释放被取出的数据的空间），没有达到复用的效果，为了改进，将这个数组使用算法改进成一个环形的数组（取模%）\n数组模拟环形队列使用数组模拟环形队列的思路分析：\n\n队列的大小为 k 的话，就创建 k+1 大小的环形队列（空出一个空间来）maxSize 为有效数据个数+1\nfront 变量的含义做一个调整：front 指向队列的第一个元素（而不是原来指向头元素的前一个位置）即 arr [front] 即队列的第一个元素，front 的初始值默认为 0\nrear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置，希望空出一个空间作一个“约定”，rear 的初始值为 0\n当队列满时，条件是 (rear+1)%maxSize &#x3D;&#x3D; front\n队列为空的条件仍然是 rear&#x3D;&#x3D;front\n队列中有效数据的个数：**(rear+maxSize-front)%maxSize**\n\n下列图片判断环形队列是否为满（重点）\n在 front &#x3D; 0，rear &#x3D; 3，maxSize &#x3D; 8 的情况下，（rear + 1） % maxSize &#x3D; 4，而 4 !&#x3D; 0，所以数组没有满，依然可以存储数据。在 front &#x3D; 0，rear &#x3D; 7，maxSize &#x3D; 8 的情况下，（rear + 1） % maxSize &#x3D; 0，而 0 &#x3D; 0，数组已经存满\n\n\n代码实现环形队列\njavaclass ArrayQueue&#123;\n  private int maxSize;//表示数组的最大容量\n  private int front;//指向队列头, 初始值为 0\n  private int rear;//指向队列尾的后一个元素，初始值为 0\n  private int[] arr;//该数组用于存放数据: 模拟队列\n  //构造器\n  public ArrayQueue(int arrMaxSize)&#123;\n      maxSize = arrMaxSize;\n      arr = new int[maxSize];\n      fornt = 0;\n      rear = 0;\n      //两个值默认就是 0，可以不赋值\n  &#125;\n    public boolean isFull()&#123;\n        return (rear+1) % maxSize == front;\n    &#125;\n    public boolean isEmpty()&#123;\n        return front == rear;\n    &#125;\n    public void addQueue(int n)&#123;\n        if(isEmpty())&#123;\n            System.out.println(&quot;队列满&quot;);\n            return;\n        &#125;\n        //先将数据后移，在存入数据，必须将 rear 取模\n        arr[rear] = n;\n        rear = (rear+1) % maxSize;\n    &#125;\n    public int getQueue()&#123;\n        if(isEmpty())&#123;\n            throw new RuntimeException(&quot;队列空&quot;);\n        &#125;\n        //分析出 front 是指向队列的第一个元素\n        //先把 front 保存到临时变量，再将 front 后移(考虑取模)\n        int value = arr[front];\n        front = (front+1) % maxSize;\n        return value;\n    &#125;\n    public void showQueue()&#123;\n        if(isEmpty())&#123;\n            System.out.println(&quot;队列空，没有数据~&quot;);\n            return;\n        &#125;\n        //从 front 开始遍历, 遍历(rear+maxSize-front)%maxSize 个元素\n        for(int i = front;i&lt;front+size();i++)&#123;\n            System.out.printf(&quot;arr[%d]=%d\\n&quot;,i % maxSize,arr[i%maxSize]);\n        &#125;\n    &#125;\n    //需要一个方法求出当前队列有效数据的个数\n    public int size()&#123;\n        return (rear+maxSize-front) % maxSize;\n    &#125;\n    public int headQueue()&#123;\n        if(isEmpty())&#123;\n            throw new RuntimeException(&quot;队列空&quot;);\n        &#125;\n        return arr[front];\n    &#125;\n&#125;\npublic class CircleArrayQueue&#123;\n    public static void main(String[] args)&#123;\n      //测试一下\n      //创建一个环形队列\n      ArrayQueue queue = new ArrayQueue(4);\n      char key = &#39; &#39;;//接收用户输入\n      Scanner scanner =new Scanner(System.in);\n      boolean loop = true;//默认死循环\n      //输出一个菜单\n      while(loop)&#123;\n          System.out.println(&quot;s(show):显示队列&quot;);\n          System.out.println(&quot;e(exit):退出程序&quot;);\n          System.out.println(&quot;a(add):添加数据到队列&quot;);\n          System.out.println(&quot;g(get):从队列取出数据&quot;);\n          System.out.println(&quot;h(head):查看队列头的数据&quot;);\n          key = scanner.next().charAt(0);\n          switch(key)&#123;\n              case &#39;s&#39;:\n                  queue.showQueue();\n                  break;\n              case &#39;a&#39;:\n                  System.out.println(&quot;输出一个数&quot;);\n                  int value = scanner.nextInt();\n                  queue.addQueue(value);\n                  break;\n              case &#39;g&#39;:\n                  System.out.println(&quot;取出队列数据&quot;);\n                  try&#123;\n                      //因为从队列中取出数据会先判断队列是否为空，空队列时会抛出异常，这时候使用 java 的异常处理机制 try-catch 来处理\n\n                      int res = queue.getQueue();\n                      //如果 getQueue 抛出异常就会被下面的 catch 抓住\n                      System.out.printf(&quot;取出的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      //如果抛出异常，就输出 e 中的异常\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;h&#39;:\n                  System.out.println(&quot;查看队列头数据&quot;);\n                  try&#123;\n                      int res = queue.headQueue();\n                      System.out.printf(&quot;队列头的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;e&#39;:\n                  scanner.close();\n                  loop=false;\n                  break;\n              default:\n                  break;\n          &#125;\n          System.out.println(&quot;程序退出&quot;);\n      &#125;\n  &#125;\n&#125;链表链表是有序的列表，内存存储如下\n\n\n链表以节点的方式存储，是链式存储\n每个节点包括 data 域，next 域：指向下一个节点\n每个节点不一定是连续存放\n链表分为带头节点的链表和没有头结点的链表，根据实际需求来确定\n\n逻辑结构如下：\n逻辑结构好似的连续的，但实际的内存存储一般是不连续的\n使用带 head 头的单向链表实现人物排行榜管理\n要求：\n\n完成对人物的增删改查的操作\n第一种方法在添加人物时，直接添加到链表尾部\n第二种方式在添加任务时，考虑人物排名\n\n代码的具体实现\njavapackage com.data.LinkList;\n\n//先定义一个 Node，每个 Node 对象是一个节点\nclass Node&#123;\n  public int no;\n  public String name;\n  public String nickname;\n  public Node next;//指向下一个节点的 next 域\n  //创建构造器\n  public Node(int No,String Name,String Nickname)&#123;\n      this.no=No;\n      this.name=Name;\n      this.nickname=Nickname;\n  &#125;\n  //显示方法：重新 toString\n  public String toString() &#123;\n        return &quot;Node [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname;\n    &#125;\n&#125;\n//定义一个 SingleLinkList 管理人物\nclass SingleLinkListDemo&#123;\n  //初始化一个头节点，头节点不存放具体数据\n  private Node head = new Node(0,&quot;&quot;,&quot;&quot;);\n  //添加节点\n  //不考虑编号顺序时，找到当前链表的最后节点，next 域直接指向新的节点即可\n  public void add(Node node)&#123;\n      //head 节点不能动，所以需要定义一个辅助变量\n      Node temp = head;\n      //遍历\n      while(true)&#123;\n          //当找到链表的尾部\n          if(temp.next == null)&#123;\n              break;\n          &#125;\n          //如果没有找到最后\n          temp = temp.next;\n          //当推出 while 循环时，temp 一定是指向链表的最后\n      &#125;\n      temp.next = node;\n  &#125;\n  //显示链表遍历链表\n  public void list()&#123;\n      //判断链表是否为空\n      if(head.next == null)&#123;\n          System.out.println(&quot;链表为空&quot;);\n      &#125;\n      //链表不为空时，头结点不能动，需要一个辅助变量遍历\n      Node temp = head.next;\n      while(true)&#123;\n          //判断是否到链表最后\n         if(temp == null)&#123;\n             break;\n         &#125;\n          //输出节点信息, 再将 temp 后移\n          System.out.println(temp);\n          temp = temp.next;\n      &#125;\n  &#125;\n    public void addByOrder(Node node)&#123;\n        Node temp = head;\n        boolean flag = false;\n        while(true)&#123; \n            if(temp.next = null)&#123;\n                break;//temp 在链表尾部\n            &#125;\n            if(temp.next.no&gt;node.no)&#123;//在 temp 后面添加\n                break;\n            &#125;else if(temp.next.no = node.no)&#123;//添加的编号已经存在了\n                flag == true;//编号存在\n                break;\n            &#125;\n            temp = temp.next;//后移，遍历当前链表\n        &#125;\n        //退出循环后，判断 flag 的值\n        if(flag== true)&#123;//flag 为真，不能添加，说明编号存在\n            System.out.printf(&quot;编号%d已经存在\\n&quot;,node.no);\n        &#125;else&#123;\n            //插入到链表中了\n            node.next = temp.next;\n            temp.next = node;\n        &#125;\n    &#125;\n&#125;\npublic class SingleLinkList &#123;\n    public static void main(String[] args)&#123;\n        //测试一下\n        //先创建节点\n        Node h1 = new Node(1,&quot;穆佳一&quot;,&quot;老大&quot;);\n        Node h2 = new Node(2,&quot;王兆淼&quot;,&quot;老二&quot;);\n        Node h3 = new Node(3,&quot;小王兆淼&quot;,&quot;老三&quot;);\n        Node h4 = new Node(4,&quot;小小王兆淼&quot;,&quot;老四&quot;);\n        //加入之前，创建一个链表\n        SingleLinkListDemo singleLinkList = new SingleLinkListDemo();\n        //加入\n        singleLinkList.add(h1);\n        singleLinkList.add(h2);\n        singleLinkList.add(h3);\n        singleLinkList.add(h4);\n        //显示一下\n        singleLinkList.list();\n        \n    &#125;\n\n&#125;\n下面代码块介绍节点修改的代码\n修改节点时，编号不变，节点的信息改变\njava//根据编号修改\npublic void update(Node newnode) &#123;\n    if(head.next==null)&#123;\n        System.out.println(&quot;链表为空&quot;);\n        return;\n    &#125;\n    //找到要修改的节点\n    Node temp = head.next;\n    boolean flag = false;//表示是否找到该节点\n    while(true)&#123;\n        if(temp == null)&#123;\n            //到了链表最后了\n            break;\n        &#125;\n        if(temp.no == newnode.no)&#123;\n            flag = true;\n            break;\n        &#125;\n        temp = temp.next;\n    &#125;\n    //根据falg判断是否找到节点\n    if(flag)&#123;\n        temp.name = newnode.name;\n        temp.nickname = newnode.nickname;\n    &#125;else&#123;\n        //没有找到\n        System.out.println(&quot;没有找到该编号对应的节点&quot;);\n    &#125;\n&#125;","slug":"Java数据结构和算法","date":"2024-01-24T12:30:11.000Z","categories_index":"编程","tags_index":"Java","author_index":"Ed-RYan"},{"id":"fa8c242a44c2320cdf0d2adc7864bdb1","title":"蓝桥杯知识点汇总","content":"蓝桥杯知识点汇总基础算法\n\n\n枚举\n模拟\n贪心\n递归\n分治\n\n\n\n构造\n前缀和差分\n\n\n\n\n\n搜索和排序\n\n\n子集生成\n线性搜索\n二分法\n三分法\nBFS\n\n\n\n双向广搜\n广搜优化\nA 算法\nDFS\n回溯剪枝\n\n\n深搜优化\n记忆化搜索\nIDA 算法\n位运算\n按位压缩存储状态\n\n\n极大极小问题\nM 进制存储状态\n舞蹈链\n选择排序\n冒泡排序\n\n\n插入排序\n归并排序\n快速排序\n堆排序\n计数排序\n\n\n基数排序\n桶排序\n\n\n\n\n\n动态规划\n\n\n编辑距离\n最长不重复子串\n整数背包\n矩阵连乘\n最长公共子序列\n\n\n\n最长公共递增子序列\n最长公共子串\n最长上升子序列\n最长回文子序列\n最长回文子串\n\n\n回文分割\n最大子段和\n最大正方形子矩阵\n最长链对\n最大递增子序列和\n\n\n滚动数组\n\n\n\n\n\n\n数位 dp\n概率 dp\n树形 dp\n区间 dp\n状压 dp\n\n\n插头 dp\n斜率优化\n平行四边形优化\n单调队列优化\n数据结构优化\n\n\n数学\n\n\nGCD&amp;LCM\n素数判断\n素数生成\n分解质因数\n欧拉定理\n\n\n\n费马小定理\n扩展欧几里得\n逆元\n随机素数测试和大数分解\n高斯消元\n\n\n佩尔方程\n整数拆分\n大步小步算法\n中国剩余定理\n原根\n\n\n快速数论变换\n线性丢番图方程\n模运算\n卢卡斯定理\n杜教筛\n\n\n威尔逊定理\n米勒罗宾随机素数测试\n完全数\n连分数\n\n\n\n组合数学\n\n\n容斥原理\n鸽巢定理\n乘法原理\n斯特林数\n卡特兰数\n\n\n\n斐波那契数\n幻方\n莫比乌斯反演\n母函数\n调和级数\n\n\n图论\n\n\n邻接矩阵、关联矩阵\n邻接表\n链式前向星\n有向无环图\n哈密顿图\n\n\n\n欧拉图\n判圈\n割点\n割边\n桥\n\n\n双连通分量\n强连通分量\n有向图的强连通分量\n拓扑排序\n二分图判定\n\n\n2-SAT\n最短路径\n连通分量\nPrim\nKruskal\n\n\n次小生成树\n曼哈顿最小生成树\n堆优化\nBellman\n弗洛伊德算法\n\n\n差分约束\nSPFA\n最小费用最大流\n二分图匹配\n欧拉路\n\n\n数据结构\n\n\n数组\n链表\n栈\n队列\n先队列\n\n\n\n双端队列\n块状链表\n堆\n哈希\nLCA\n\n\n跳跃表\n并查集\n字典树\n线段树\n树状数组\n\n\n莫队算法\n平衡二叉树\n二叉搜索树\nTreap 树\n二叉树\n\n\n笛卡尔树\n划分树\n表达式树\n替罪羊树\n伸展树\n\n\n动态树\n左偏堆\n可并堆\n主席树\n树链剖分\n\n\nKD 树\n树套树\nFHQ_Treap\n\n\n\n\n几何\n\n\n点和向量\n点积、叉积\n点和线的关系\n多边形\n三角形的内心、外心、重心、垂心\n\n\n\n费马点\n面积、周长、体积\n判点在多边形多面体内外\n三角剖分\n梯形剖分\n\n\n多边形重心\n多边形切割\n多面体体积\n坐标旋转\n凸包\n\n\n最近点对\n旋转卡壳\n半平面交\n最小圆覆盖\n\n\n\n三维点和向量\n三维点积&amp;叉积\n最小球覆盖\n三维凸包\n\n\n\n","slug":"LqKnowledgePoint","date":"2024-01-23T02:13:50.000Z","categories_index":"","tags_index":"算法","author_index":"Ed-RYan"},{"id":"50dae02cf68f09e79955ea48c8fd607c","title":"瞎学的java基础语法","content":"ε &#x3D;(´ο｀*)))唉，上次用 Java 还是在上次，感觉语法什么的已经忘得干干净净了，先来总结一些我易混的知识点啥的恢复一下记忆\nJava标识符定义：包（package），类（Class），方法（Method），变量（Variable）起名字的符号\n组成规则：由字母、数字、下划线“_”、美元符号$或者￥组成，首字符不能是数字，不能是 Java 中的关键字，大小写敏感，无长度限制，不能包含空格。\nJava 注解定义：用于解释说明程序的文字\n分类：单行注释“&#x2F;&#x2F;”, 快捷键：Ctrl+&#x2F;\n​\t\t\t多行注释”&#x2F; * 注释文字 * &#x2F;“”，快捷键：Ctrl+Shift+&#x2F;\nJava 访问修饰符定义： 使用访问修饰符可以保护对类、变量、方法、构造方法的访问，Java 中有四种不同的访问权限\n分类： private：在同一类（Class）内可见，不能修饰类（外部类）\n​\t\t\tdefault：（缺省，什么也不写，不使用关键字）在同一包（package）内可见，不适用任何修饰符，也叫包访问权限。\n​\t\t\tprotected：对同一包内的类和所有子类可见。不能修饰类（外部类）\n​\t\t\tpublic：对所有类可见\n拓展：一个 Java 源程序中可以有多个 Class 类，但只能有一个类是 public 的。\n​\t\t\tjava 程序是从一个 public 程序中的 main 函数开始执行的，就像 C++程序从 main（）开始执行一样。\n​\t\t\t只能有一个 public 是为了给 类装载器 提供方便，public 只能定义在以他的类名为文件名的文件中（严格区分大小写）\nJava 分隔符、转义符分隔符定义：空格、逗号、分号以及行结束符，规定任意两个相邻标识符、数字、保留字、语句之间必须存在至少一个分隔符，以保证程序编译时能正常识别。\n分类：\n\n​\t\t\t分号“；”\t用于终止一个语句\n​\t\t\t冒号“：”\t\n​\t\t\t花括号、大括号“{}”\t用于包括自动初始化数组的值，也用于定义程序块、类、方法以及局部范围。\n​\t\t\t方括号、中括号“[]”\t用于声明数组类型，也用于撤销对数组值的引用。\n​\t\t\t逗号“，”\t在变量声明中，区分变量说明的各个变量。在 for 控制语句中将圆括号内的语句连接起来\n​\t\t\t圆点“.”\t将软件包的名字和他的子包或类相分隔，也用来将引用变量与变量或者方法分隔\n​\t\t\t圆括号“（）”\t定义和调用方法时容纳参数表，在控制语句或者强制类型转换表达式中表示执行或者计算的优先权\n​\t\t\t尖括号“&lt;&gt;”\t将参数传递给参数化类型\n\n转义符定义：特殊的字符常量，以反斜线“\\”开头，后跟一个或者几个字符，通常具有特定的含义，不同于字符原有的意义。\n常用转义字符\n\n\n\n转义字符\n意义\nASCII 码制\n\n\n\n\\n\n换行符（LF）\n10\n\n\n\\r\n回车（CR）\n13\n\n\n\\y\n水平制表（HT）（一个 Tab）\n9\n\n\n\\v\n垂直制表（VT）\n11\n\n\n\\\\\n代表一个反斜线字符‘\\’\n92\n\n\n\\‘\n代表一个单引号字符\n39\n\n\n\\“\n代表一个双引号字符\n34\n\n\n\\0\n空字符（NULL）\n0\n\n\nJava 数据类型定义：Java 是强制类语言，对于每一种数据定义明确了具体的数据类型，内存中分配不同大小的内存空间\n基本数据类型数值型\n整数类型\t\n\n\n\n数据类型\n字节\n位数\n\n\n\nbyte\n1\n8\n\n\nshort\n2\n16\n\n\nint\n4\n32\n\n\nlong\n8\n64\n\n\n定义 long 类型时要在后面加后缀 L 或者 l\n浮点类型\n\n\n\n数据类型\n字节\n位数\n\n\n\nfloat\n4\n32\n\n\ndouble\n8\n64\n\n\n定义浮点类型时候后缀没有 F 或者 f 时候默认是 double 类型，float 类型赋值时需要添加后缀 F 或者 f\n字符型\nchar，采用 Unicode 编码，两字节表示一个字符，\n布尔型\nblloean，1 字节表示一个字符\n引用数据类型类(class)接口(interface)数组([])\n简单数据转换Java 中整形，实型（浮点型），字符型都被称为简单数据类型，这些类型由低级到高级分别为：\n（byte，short，char） - int - long - float - double\n简单数据类型之间的转换又分为：\n\n低级到高级的自动类型转换\n\n高级到低级的强制类型转换（可能导致溢出或者精度下降）\n\n包装类过渡类型能够转换\n\n\njava//自动类型转换\n  byte b;\n  int i=b;\n  long l=b;\n  float f=b;\n  double d=b;\njava//低级类型为 char 型，向高级类型（整形）转换，会转换为对应的 ASCII 码\nchar c=&#39;c&#39;;\nint i=c;\n//System.out.println(&quot;output:&quot; i);\n//输出：output: 99;javapublic static void main(String[] args) &#123;\n    //1.多个类型数据混合运数时，系统会按最大的类型进行转换\n    int a = 10;\n    //float a1 = a + 1.1; //错误  结果类型一个是 double\n    float a2 = a + 1.1F;  //结果类型一个是 float\n    double a3 = a + 1.1;  //结果类型一个是 double\n    //2.容量大的赋值给容量小的肯定会报错\n    //int b = 1.1; //错误 原因：double -&gt; int\n    //3.(byte，short) 和 char 之间不会相互自动转换\n    byte b1 = 10; //正确\n    int b2 = 1;\n    //byte b3 = b2; //错误 原因：变量赋值，判断该类型\n    //char c1 = b1; //错误 原因：byte 不能自动转换为 char\n    //4.byte，short，char 该三个数据类型计算，计算时首先转换为 int 类型\n    byte c1 = 1;\n    short c2 = 2;\n    //short c3 = c1 + c2; //错误 原因：计算时首先转换为 int 类型\n    int c3 = c1 + c2; //正确\n\n&#125;\nfloat 型转换为 double 型\njavafloat f1=100.00f;\nFloat F1=new Float(f1);\n//F1.doubleValue()为 Float 类的返回 double 值型的方法\ndouble d1=F1.doubleValue();\ndouble 型转换为 int 型：\njavadouble d1=100.00;\nDouble D1=new Double(d1);\nint i1=D1.intValue();\n//直接把 double 型的小数位去除字符串类的转换这里不在叙述，之后会单独开一节字符类型的学习\nJava 变量定义：在程序执行过程中，某个范围内可以发生改变 的量，从本质上讲变量其实是内存中的一小块区域。\n按被声明的位置划分成员变量：方法外部，类的内部定义的变量\n\n类变量（静态变量） 独立于方法之外的变量，用 static 修饰\n静态变量以 static 关键字声明，必须在方法构造方法和语句块之外\n静态变量存储在静态存储区，经常被声明为常量，很少单独使用 static 声明。\n静态变量第一次访问时被创建，程序结束时被销毁。\n\n\n实例变量（非静态变量） 定义在类中但在任何方法之外，没有 static 修饰\n实例变量声明在一个类当中，但是在方法、构造方法和语句块之外\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁\n\n\n局部变量\n类的方法中的变量\n局部变量声明在方法、构造方法或者语句块中\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁\n访问修饰符不能用于局部变量\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用\n\n\n\n按所属的数据类型划分基本数据类型变量\n\n基本数据类型\nbyte，short，int，float，double，char，boolean\n\n\n变量定义\n数据类型 变量名 &#x3D; 初始化值\n\n\n注意\n整型默认是 int 类型，定义 long 类型时要在数据后面加 L 或者 l，浮点型默认是 double 型，定义 float 型时需要在数据后面加 F 或者 f\n\n\n\n引用数据类型（类，接口，数组）\n\n定义格式\n数据类型 变量名 &#x3D; 初始化值\n\n\n\njavapublic class Variable&#123;\n    // 类变量\n    static int globalNum=10;    \n     // 实例变量\n    String str=&quot;hello world&quot;;  \n    public void method()&#123;\n        // 局部变量\n        int i =10;  \n    &#125;\n&#125;\nJava 常量定义：Java 中用关键字 final 定义一个常量，，常量被初始化后其值不可以发生改变。常量可以在程序执行的过程中使用一个符号来代替常量值使用，因此在使用前必须定义。\n分类：\n\n字符串类常量：用双引号括起来的内容\n整数常量：所有整数\n小数常量：所有小数\n字符常量：用单引号括起来的内容\n布尔常量：只有 true 和 false\n空常量：null\n\njavafinal int CONUT = 1;\nfinal float PI = 3.1415f;运算符定义：运算符指明对操作数的运算方式\n\n\n算数运算符\n\n\n\n\n运算符\n运算\n\n\n\n+\n加\n\n\n-\n减\n\n\n*\n乘\n\n\n&#x2F;\n除\n\n\n%\n取模\n\n\n++\n自增\n\n\n–\n自减\n\n\n+\n字符串相加\n\n\n注意事项\n\n除号&#x2F;左右两端的类型需要一致\n取模%最后的符号和被模数相同\n前++，先+1，后运算，后++，先运算，后+1\n+：当 String 字符串与其他数据类型只能做连接运算，并且结果为 String 型\n\n\n\n\n关系运算符\n\n​\t\n\n\n\n运算符\n运算\n\n\n\n&#x3D;&#x3D;\n相等于\n\n\n！&#x3D;\n不等于\n\n\n&lt;\n小于\n\n\n&gt;\n大于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;&#x3D;\n大于等于\n\n\ninstanceof\n检查是否为类的对象\n\n\n注意事项\n\nInstanceof 运算符\n语法：对象名 instanceof 类或接口\n\n\n\n\n\n\n赋值运算符\n&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;\n\n逻辑运算符\n\n\n\n逻辑运算符\n功能\n\n\n\n||（短路或）\n都为 false 则为 false，有一个为 true 便不再判断了\n\n\n|（逻辑或）\n都为 false 则为 false，所有条件都判断\n\n\n&amp;&amp;（短路与）\n都为 true 则为 true，有一个为 false 便不在判断了\n\n\n&amp;（逻辑与）\n都为 true 则为 true，所有条件都判断\n\n\n！（非）\n变成相反\n\n\n^（异或）\n相同为 false，不同为 true\n\n\n\n位运算符\n\n三目运算符\n（条件表达式 A）？表达式 1：表达式 2；\n若条件表达式 A 为 true，则运算结果为表达式 1；否则为表达式 2\n\n\nJava 流程控制——顺序控制结构顺序控制结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\nJava流程控制——选择控制结构定义：条件语句根据不同条件执行不同语句，包括if语句和switch多分支语句\nif分支结构&#x2F;if-else分支结构&#x2F;if-else if-else分支结构\nswitch分支结构\njavaswitch(/*表达式*/)&#123;\n    case 2:\n        //执行的代码\n        break;\n    case 1:\n        //执行的代码\n        default;\n            \n&#125;","slug":"javaGrammar","date":"2024-01-21T15:53:45.000Z","categories_index":"编程","tags_index":"java","author_index":"Ed-RYan"},{"id":"1451337e2cd8330994910442b8a41dbc","title":"Java学习笔记","content":"JAVA程序使用记事本编写代码\npublic 访问修饰符用于控制程序的其他部分对这段代码的访问级别\nclass是类，java是面向对象的语言，所有对象必须位于类里面\n一个源文件只能声明一个public的类，其他类个数不限，且源文件名必须和public类名相同，且以.java为后缀。\nmain方法是程序执行的入口，有固定的书写格式\njavapublic static void main(String[] args)&#123;\n    &#125;花括号的使用规范\nJava中各个语句依然必须以分号结束。回车不是结束的标志，所以一个语句可以跨多行\n注意：编程时一定注意缩进规范，写括号，引号时一定成对编写，然后再往里面插入内容。\n常用DOS命令1,cd\t目标路径\t\t进入一个子目录\n2，cd..\t\t\t进入父目录\n3，dir\t\t\t查看本目录下的子文件列表\n4，cls\t\t\t清除屏幕\n5，上下键\t\t\t查找敲过的命令\n6，Tab键\t\t\t自动补全命令\n不需要花费时间学习太多DOS命令\n因为大多数编程过程一般都是在Idea，Eplise等编辑器中进行编辑的\n变量和数据类型和运算符预备知识：\n二进制\t\t0\t\t1\n万物皆有规律，规律能量化，量化能数字化，数字化能计算机化\n二进制由莱布尼茨于1679年发明\n二进制可以对应两种状态，广泛应用于电子科学，比如可以对应电子器件开关状态，对应信号电压状态，对应电磁存储等等\n进制转换：十进制和二进制的相互转换\n满二进一\n要求掌握一些简单算法，权相加法，逆序排列法\n注释\n单行注释&#x2F;&#x2F;开头\n多行注释以\t\t&#x2F;*\t\t开头，以\t\t*&#x2F;结尾，\n文档注释\t\t&#x2F;**\t\t\t\t*&#x2F;\n注意多行注释不可以嵌套使用\n注释在编译过程中被忽略掉\n标识符\n就是起名的规则\n1，必须以字母，下划线，美元符号$开头，切记不能用数字开头\n2，标识符的其他部分还可以是数字\n3，Java标识符大小写敏感，长度无限制\n4，标识符不能是关键字\n标识符使用规范：\n表示类名的标识符：首字母大写\n表示方法和变量：第一个单词小写，第二个单词起首字母大写，称之为驼峰原则\nJava通常采用Unicode国际字符集，而不是ASCII字符集\n2个字节表示一个符号。\nACSII字符集一个字节一个符号，即2的八次方&#x3D;256个字符\nUnicode字符集2个字节一个符号，即2的十六次方&#x3D;65536个字符\n变量\n变量对应一个可操作的存储空间\n空间位置是确定的，但是里面放置什么不确定\n可通过变量名来访问对应的存储空间，从而操纵存储空间存储的值\n变量的声明：\njavatype varName [=value][,varName[=value]......];[\t]表示可有可无\nint 4个字节\ndouble 8个字节\nlong 8个字节\n变量的作用域\n\n局部变量：local variable，定义在方法&#x2F;语句块内部，\n\n成员变量\n\n静态变量\n\n\n常量\n声明格式：\njavafinal 常量类型 常量名 [=value];基本数据类型primitive date type\n数据类型分为基本数据类型和引用数据类型（引用数据类型统一大小为4字节，32位）\n基本数据类型分为数值型，字符型，和布尔型\n\n数值型又分为整数类型（byte[1],short[2],int[4],long[8]），浮点类型（float[4]，double[8]），\n字符型（char）\n布尔型（boolean）\n\n整型常量的表示形式\n\n十进制：33，44，55\n八进制：0开头\n十六进制：0x或者0X开头\n二进制：要求以0b或者0B开头\n\n定义long时应该在后面加L或者l；\n浮点型：\nfloat\t\t4字节\t\t\ndouble\t\t8字节\n浮点型是不精确的，有误差的，所以不要随便对于浮点数进行比较\n后缀没有f或者F的浮点类型默认是double类型，float类型赋值时需要添加后缀F或者f。\n字符型占两个字节，\nchar类型用于在Unicode编码中的字符，占2个字节，\nASCII码中字符型占1字节，256个字符；\n定义字符串(字符串不是基本数据类型，而是类)\njavaString str=&quot;\t\t&quot;转义字符：\n\\\n布尔类型boolean\n只有两个值true，false\n占用1个或者4个字节，不可以用0或非零的数来代替，\n运算符\n1，算数运算符\n二元运算符（+,-,*,&#x2F;,%）\n一元运算符（++，–）\n2，赋值运算符（&#x3D;）\n3，扩展运算符（+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;）\n4，关系运算符（&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;，instance of）\n5，逻辑运算符（&amp;&amp;，||，！，^）\n6，位运算符（&amp;，|，^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;）\n7,条件运算符（？：）\n8，字符串连接符（+）；\n算数运算符\nint和long运算，结果转为long，\n若没有long，则结果全为int\n两个操作数有一个为double，则结果为double\n两个操作数都是float，结果才为float\n取模运算的操作数一般为浮点数，但是一般使用整数。结果是余数，余数的符号和左边的操作数相同\n控制语句（三种基本结构）\n顺序结构\n条件判断结构\n循环结构\n条件判断（三种结构）\nif单分支\nif-else双分支结构\nif-else if-else多分支结构\nswitch语句多分支结构\njavaswitch(variable)\n&#123;\n    case 1:语句;break\n    case 2;语句;break\n    case 4.语句;default;\n&#125;循环结构\nJava程序的运行机制高级语言一般分为两种：编译型语言和解释型语言\nJava是两者的结合\n文本编译器编写源程序，后缀为.java，\n再利用编译器编译成字节码文件，后缀为.class,\n最后利用虚拟机（解释器，java）解释执行。\nJVM,JRE,JDK（是相互包含的关系)JVM，就是一个虚拟机，用于执行bytecode字节码，可以边解释便运行java的跨平台就是通过java虚拟机来运行的\n对于程序来说，编写的代码是一样的，对于用户来说，不同的系统只需要按照对应的虚拟机，来解释字节码文件。\n不同操作系统利用不同的虚拟机，来屏蔽底层运行平台的差异\nJRE，包含Java虚拟机，库函数，运行Java应用程序必须的文件JDK，包含JRE，以及增加编译器和调试器等用于程序开发的文件作为一个开发者，需要安装JDK\nJava发展简史1991开始研发，SUN公司，设计小型计算机语言\nJAVA核心优势：跨平台\n赶上互联网爆发的时代优势形成了强大的生态体系\nJava在未来几十年的时间会成为编程的主流语言\n各版本JAVASE（JAVA Standard Edition）标准版：定位在个人计算机上的应用\nJAVAEE（JAVA Enterprise Edition）企业版：定位在服务器端上的开发\nJAVAME（JAVA Micro Edition）微型版：定位在消费型电子产品上\nJava的特性和优势1，跨平台&#x2F;可移植性\njava的int永远是32位，不像c++，有时16有时32，跨平台实现不了\n2，安全\n3，面向对象\n4，简单性\n去除了头文件，指针运算，结构等等\n5，高性能\n6，分布式\n处理TCP&#x2F;IP协议\n7，多线程\n服务器端处理\nJAVA开发环境的搭建1，打开官网，安装JDK\n2，配置环境变量Path\nPath告诉计算机要运行一个程序而没有告诉其所在的完整路径时，除了在当前目录下寻找此程序外，还应该到哪些目录去寻找\n多种计算机语言介绍C语言1972，贝尔实验室，现代语言的鼻祖，\n目前在底层编程，嵌入式开发，病毒开发，系统程序，操作系统等\n学好C对学习编程非常有帮助\nC++混合式语言，既有面向过程，又有面向对象\n在科学计算，操作系统，网络通讯等方面\nJava1995，美国SUN公司，是目前业界最广泛使用人数最多的语言，称为计算机语言界的英语\n广泛应用于企业级软件开发，安卓移动开发，大数据云计算等领域，\nJavascript脚本语言，广泛应用于Web开发\nH5的开发核心是Javascript\nPython1989年，早于Java\n之前广泛应用于科研领域，WEB编程等等，但是目前在人工智能方面具有巨大潜力\nPHP一般用于WEB开发\n大量中小型网站使用PHP开发，\nObject-C和Swift语言苹果开发\nC#（C-sharp）微软公司，面向对象，运行于.NET框架平台之上的高级程序设计语言\n基于Windows操作系统应用开发这一块取代了C++，微软\nKotlin语言（考特林）目前已经正式成为安卓官方支持的语言，且可以兼容Java\nGo语言谷歌官方开发的语言\n易语言以中文作为程序代码编程语言，目前主要用来开发脚本，外挂等程序\nFortran语言IBM公司，1954\n复杂科学计算，工程领域\nBasic语言易学，功能不够强大，已经退出历史舞台\nPascal语言COBOL语言计算机语言发展史及未来发展方向工业革命——————解放体力\n信息革命——————解放脑力\n计算机已经成为了人类大脑的延伸计算机随处可见，手机，玩具，微波炉，洗衣机，汽车等，都有计算机的出现\n算法是计算机的灵魂，编程语言是塑造计算机灵魂的工具计算机编程语言经历了从低级到高级的发展，发展核心思想是“让人更容易编程”\n3个阶段\n1，机器语言（相当于人类的原始社会）\n通常是纯数字，0和1\n2，汇编语言（相当于人类的工业阶段）\n使用常见的汇编语言助记符\n在某些工业电子编程领域，软件的加密解密，计算机病毒分析等仍在使用\n3，高级语言（相当于人类的工业社会）\n程序开始非常易懂\n面向对象类和对象，内存底层，面向对象的三大特征，特殊类\n一，熟悉面向对象1，表格结构和类结构\n\n\n类（表结构）\nID\nName\nMoney\nDate\n\n\n\n对象\n0001\n张三\n1000\n9&#x2F;1\n\n\n对象\n0002\n李四\n2000\n10&#x2F;1\n\n\n对象\n0003\n王五\n3000\n11&#x2F;1\n\n\n类对应表格的结构，对象对应表格的内容\n一行数据对应一个对象，而表头（表结构）则对应的是类\n如果未来要学习数据库，数据库，就是一张张的表，在一张张表中调用和存储数据就是对对象和类的应用\n\n\n\n雇员表结构（类）\nClass Employee\n\n\n\nID\nint ID\n\n\nName\nString Name\n\n\nMoney\nString Money\n\n\nDate\nString Date\n\n\n晨会动作\nvoid kaichenhui(){}\n\n\n表格的动作和类的方法在类中定义成方法，即对每个对象都作用动态\n二、面向过程和面向对象思想联系1、面向对象和面向过程的区别面向过程：执行者思维，关注的是怎么实现\n对于一件事，首先考虑第一步干什么，第二步干什么，第三步……\n面向对象：对每一个对象操作\n假设要建一艘航母，一艘航母要由几百万甚至几亿个零件来构成，如果是面向过程，就要考虑对于建造航母，第一步该干什么，第二步该干什么，而操作对象仅为个体的零件，但如果是面向对象，我们首先考虑的就是如何设计这个事物，而不是按照步骤建造的问题，这之间的差别是思维模式的转变。\n比如，使用面向对象的思想来思考如何设计车\n天然的，我们就会从“车由什么组成”开始思考，发现车由以下对象构成\n\n轮胎\n发动机\n车壳\n座椅\n玻璃\n\n为了便于协作，去找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤……这样，大家可以同时进行汽车的制造，最终进行组装，大大提高了效率\n综上所述，面向对象可以帮助我们从宏观上把握，从整体上分析整个系统，但是具体到部分的微观操作仍然需要面向过程的思想去处理。\n面向对象和面向过程都是解决问题的思维方式，都是代码组织的方式。\n面向过程是一种执行者思维\n面向对象是一种设计者思维\n面向对象离不开面向过程：宏观上通过面向对象进行整体设计，微观上执行和处理数据，仍然是面向过程\n（简单的问题使用面向过程的思维方式就可以了，而复杂问题需要通过面向对象的组织思想）\n面向对象分析：写诗\n登鹳雀楼\n白日依山尽\n黄河入海流\n欲穷千里目\n更上一层楼\n\n外在场景：太阳，天空，黄河，河流交汇处，鹳雀楼，草\n诗人情怀：登高望远，进取，努力\n描述过程：由远及近，再到自身情怀\n可以用表格来表示以上信息\n\n\n\n物体\n物体类别\n别称（雅称）\n\n\n\n太阳\n实物\n金虎，赤乌，阳乌，朱雀……\n\n\n天空\n实物\n皇天，天宇，玉宇……\n\n\n黄河\n实物\n大河，母亲河，上河……\n\n\n草\n实物\n芦苇……\n\n\n鹳雀楼\n实物\n楼……\n\n\n登高望远\n虚物\n……\n\n\n进取\n虚物\n……\n\n\n努力\n虚物\n天天向上……\n\n\n完成以上Object以后，就需要进行组合，将这些Object融合到一个场景\n以上就是使用面向对象的思维来写的一首诗。\n面向对象分析：写小说对于一部小说，里面的场景，人物等等对象，都是事先构思好的，顺着大致的脉络一篇一篇往下写。\n三、对象和类的详解1，类和对象的概念在去认识一个事物的时候，肯定是去先去见一下实物，自己才能够再去抽象一种概念，一种理解。\n从认识的角度来理解，先有一个真实的物体，然后主观抽象出一个类，才能有这么一个对象。\n总结的过程就是抽象的过程\n类可以看作一个模板（表结构），或者图纸，系统根据类的定义来造出对象。\n类：我们叫做Class，对象：我们叫做Object，通常说某个类的对象，某个类的实例，是一样的意思。\n定义好类之后，一般会有三种常见的成员：属性，方法，构造器\n属性：定义该类或者该类对象所包含的数据或者说静态特征（也叫成员变量）\n方法：用于定义该类或者该类实例的行为特征或者功能实现（动态）\n构造器：也叫做构造方法，用于对象的初始化；\n构造器的四个要点\n\n构造器通过new关键字调用！\n构造器有返回值，但是不能定义返回值的类型，不能写返回值，不能return\n如果没有定义构造器，则编译器会构造一个无参数的构造器。\n构造器方法名必须和类名一致！\n\n2，内存分析内存模型\n\n线程：程序计数器，虚拟机栈，本地方法栈\n堆：新生代，老年代\n方法区：运行时常量池\n直接内存\n其他内存\n\n执行过程的内存分析\n通过内存分析更深刻的理解对象\nJava虚拟机内存模型概念\n线程分为程序计数器，虚拟机栈，本地方法栈。\n堆：创建的Java对象都在堆里面\n方法区：一种Java虚拟机的规范\n程序执行的内存分析过程（掌握）Java虚拟机分为：虚拟机栈，堆，方法区\n虚拟机栈\n栈描述的是方法执行的内存模型。每个方法会创建一个栈帧（存储局部变量，操作数，方法出口等。）\nJVM会为每个线程创造一个栈 \n栈属于私有，不能在线程之间共享\n栈的存储特性是“先进后出，后进先出”\n栈由系统自动分配，速度快，栈是一个连续的存储空间\n\n堆\n用于存储创建好的对象和数组（数组也是对象）\nJava只有一个堆，被所有线程共享\n堆是不连续的，分配灵活，速度慢\n\n方法区\n方法区是Java虚拟机规范，可以有不同实现\nJVM只有一个方法区，被所有线程共享\n方法区实际上也是堆，只是用于存储类，常量等相关信息\n用来存放程序中永远是不变或者唯一的内容\n\n3，垃圾回收机制内存管理：Java内存管理中很大程度指的就是：堆中对象的管理\n对象空间的分配：使用new关键字创建对象\n堆空间的释放\n垃圾回收算法：1，引用计数法，引用 次数达到上限后自动释放空间\n2，引用可达法（根搜索法）\n4，分代垃圾回收机制\n年轻代，所有新生成的对象首先放置Eden区，年轻代的目标尽可能尽快收集掉那些生命周期短的对象，年轻代区域放满对象后，就将对象存放到年老代区域\n年老代，年轻代中经历了N(默认15)次以后仍然存活，就会被放到年老代，属于生命周期较长的现象\n永久代，用于存放静态文件，如Java类，方法等。\n\nthis，static关键字this关键字对象创建的过程和this的本质创建一个对象：1，分配空间，初始化为0或Null，2，执行属性值显式初始化，3，执行构造方法，4，返回对象地址给相关变量\n this可以构造初始化方法，避免相同name\n","slug":"Java","date":"2024-01-21T08:53:49.000Z","categories_index":"编程","tags_index":"Java","author_index":"Ed-RYan"},{"id":"e20937b340b4576fb9a9923d14634252","title":"commonSoftware","content":"王兆淼王兆淼\n","slug":"commonSoftware","date":"2024-01-21T05:14:54.000Z","categories_index":"","tags_index":"","author_index":"Ed-RYan"},{"id":"8de2812c284cf8a360f926e81ed1f70d","title":"Multisim14.3安装教程","content":"一、下载链接Multisim14.3 下载链接：\n链接：https://pan.baidu.com/s/1JJyRK-RI0uWKtufmu9avgQ?pwd &#x3D; df20 提取码：df20 \n二、安装过程（傻瓜式安装过程）首先打开 setup 文件夹\n然后右键 Install.exe 文件，选择 以管理员身份运行。\n选择“我接受上述许可协议”(显而易见的)点击下一步\n采用默认选项，勾选“禁用 Windows 快速启动”后点击下一步\n继续点击下一步\n接着等待安装\n接着弹出 CircuitDesignSuite 的安装窗口，和刚刚一样，选择“我接受上述许可协议”点击下一步\n接着点击下一步\n接着是漫长的等待\n安装过程中会出现一个弹窗，注意要点击“否”\n安装完成，会自动提示你激活软件，这个时候点击取消\n还会提示你重启完成操作，这个时候不用重启，直接点击右上方的小叉叉关闭这个窗口\n接着回到刚刚解压目录下，打开解压的文件夹 Crack，里面是一个激活器，把它解压到当前文件夹（注意，解压这个文件的时候一定要关闭电脑上的所有杀毒软件，防火墙以及 WindowsDefender，否则该激活器可能会被杀毒软件误杀而导致激活失败）\n解压完成后，右键刚刚 Crack 文件夹解压的 NI License Activator 1.2, 以管理员身份运行，鼠标右键 Base Edition，选择 Activate，接着以同样的方法把下列选项全部 Activate，效果图如下\n接着打开刚刚解压的“汉化”文件夹，将 Chinese-simplified 文件夹复制\n接着是寻找你刚刚安装的 Multisim 软件的位置，可以点击桌面任务栏的开始图标，因为软件刚刚安装，Multisim 软件会列出在推荐项目中，点击右键，选择打开文件位置\n继续右键，选择打开文件所在位置\n这时候就来到了 Multisim 的安装目录，划到最上面，打开 stringfiles 文件夹\n右击空白处点击粘贴\n这个时候就安装成功了！可以从刚刚桌面任务栏处的开始图标点击 NI Multisim14.3 打开软件\n","slug":"Multisim","date":"2024-01-20T15:30:00.000Z","categories_index":"常用软件","tags_index":"教程","author_index":"Ed-RYan"},{"id":"1320fe65ed8f0eda865a406ac126c548","title":"Typora1.5.6中文版安装使用说明","content":"Typora是一款Markdown编辑器和查看器，主要用于创建和编辑Markdown格式的文档， 而Markdown文档可以轻松地转换为其他格式，如HTML、PDF、Word等。这种可移植性使得Markdown成为在不同平台和工具之间共享文档的不错选择，Typora是一个简便而强大的工具，下面给大家发放下载链接和安装教程。\n一、下载链接：Typora1.5.6下载链接：\n链接：https://pan.baidu.com/s/154gbZk8gY3OwIgiBLE-V8Q?pwd=7jyr 提取码：7jyr \n二、安装下载完成后解压压缩包，压缩包中有两个文件，一个是我们的Typora安装包，另一个是安装密码。\n解压后打开安装包，出现以下界面：\n\n\n输入我们的安装密码：12345678\n然后选择安装路径（建议安装到C盘以外的盘符）\n\n\n之后的选项都为默认选项\n安装结束后出现以下画面：\n\n\n点击Finish后安装结束。\n","slug":"Typora","date":"2024-01-20T15:30:00.000Z","categories_index":"常用软件","tags_index":"教程","author_index":"Ed-RYan"}]