[{"id":"ff174011d8c5d18056300c9905301265","title":"STM32","content":"","slug":"STM32","date":"2024-03-20T14:45:31.000Z","categories_index":"","tags_index":"","author_index":"Ed-RYan"},{"id":"87122f1313843578dbea5a21e7a0d4c1","title":"中断","content":"中断相关概念中断\nCPU在处理某一事件A时，发生了另一事件B请求CPU迅速去处理（中断发生）；\nCPU暂时中断当前的工作，转去处理事件B（中断响应和中断服务）；\n待CPU将事件B处理完毕后，再回到原来事件A被中断的地方继续处理事件A（中断返回），这一过程称为中断 。\n\n\n中断源引起CPU中断的根源，称为中断源。解释：中断源向CPU提出的中断请求。CPU暂时中断原来的事务A，转去处理事件B。对事件B处理完毕后，再回到原来被中断的地方（即断点），称为中断返回。实现上述中断功能的部件称为中断系统。\n\nSTC89C5X 系列单片机提供了 5-8 个中断请求源，它们分别是：\n\n外部中断 0 (INT0)\n外部中断 1 (INT1)\n外部中断 2 (INT2)\n外部中断 3(INT3)\n定时器 0 中断(T0)\n定时器 1 中断(T1)\n定时器 2 中断\n串口(UART)中断\n\n（注意：51 系列单片机一定有基本的 5 个中断，但不全有 8 个中断，需要查看芯片手册，通常我们使用的都是基本的 5 个中断：INT0、INT1、定时器 0&#x2F;1，串口中断）。\n\n(用外部中断0来举例子）\n（P3.2）可由IT0(TCON.0)选择其为低电平有效还是下降沿有效。当CPU检测到P3.2引脚上出现有效的中断信号时，中断标志IE0(TCON.1)置1，向CPU申请中断。TF0（TCON.5），单片机内定时&#x2F;计数器T0溢出中断请求标志。当定时&#x2F;计数器T0发生溢出时，TF0&#x3D;1，并向CPU申请中断。RI（SCON.0）或TI（SCON.1），串行口中断请求标志。当串行口接收完一帧串行数据时置位RI或当串行口发送完一帧串行数据时TI&#x3D;1，向CPU申请中断。\n中断允许控制位（IE）CPU对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE控制的。\n\n中断请求标志\n中断优先级\n中断响应条件（必须同时满足）\n\n","slug":"中断","date":"2024-03-18T11:32:14.000Z","categories_index":"","tags_index":"","author_index":"Ed-RYan"},{"id":"4017b0859f618ced4ab82641491736f2","title":"基于51单片机的C语言延时函数底层原理","content":"延时函数在单片机运行的代码中，由于我们计算机的速度是很快的，执行每一条代码的速度也是很快的，也就仅有几微秒而已，是我们肉眼观察不到的。根据开发者的需求，有时候我们需要代码执行后等待一定时间，再去执行下一条，这个时候我们需要用到延时函数。\n最简单的延时函数是让CPU处于跑空的状态，就是利用while循环来跑空，等while跑完在进行下一条。\n需要注意的是，对于不同晶振的频率不同，程序的延时时间是不同的\n周期时钟周期时钟周期也称为震荡周期，定义为时钟脉冲的倒数，也就是晶振频率的倒数。\n在51单片机中，一个时钟周期定义为一个节拍（用P表示），2个节拍定义为状态周期（用S表示）。\n时钟周期是单片机中的最小时间单位\n例：12Mhz晶振的单片机，时钟周期&#x3D;震荡周期&#x3D;1&#x2F;12微秒。\n状态周期每个状态周期的为时钟周期的两倍，也就是刚刚上面说过的两个节拍，一个状态周期可以完成一个或者多个微操作。\n指令周期指执行一条指令所需要的时间，通常，指令周期可分为单周期指令和双周期指令，包含一个机器周期的指令成为单周期指令，包含两个机器周期的指令成为双周期指令，同理，还有四周期指令等。\n机器周期机器周期被定义为是完成一项基本操作所需要的时间。在计算机中，为了方便管理，把一条指令的执行过程分为若干个阶段，每个阶段去执行一项基本操作如：取指令，存储器读，存储器写等。\n在51单片机中，一个机器周期由6个状态周期组成，也就是12个时钟周期：12×1&#x2F;12us&#x3D;1us\n定义机器周期是因为时钟周期的时间太短，根本做不了什么。\n\n\n根据上述定义，我们可以得到以下关系：\n\n\n1个振荡周期&#x3D;1个时钟周期\n1个状态周期&#x3D;2个时钟周期\n1个机器周期&#x3D;6个状态周期&#x3D;12个时钟周期\n1个指令周期&#x3D;N个机器周期&#x3D;6N个状态周期&#x3D;12N个时钟周期\n\n\n\n例如：外接晶振为 12MHz 时，51 单片机相关周期的具体值为： 时钟周期（振荡周期）&#x3D;1&#x2F;12us; 状态周期&#x3D;1&#x2F;6us; 机器周期&#x3D;1us; 指令周期&#x3D;1~4us\n\n对于我们关注的12T，1T单片机等等是指一个机器周期所需要的时钟周期数目，我们所学习的STC89C51系列单片机有两种模式，一种是12T模式，每12个时钟+1,与传统8051相同，另外一种是6T模式，每6个时钟加1，速度是传统8051的两倍。\n对于程序取值的理解利用for语句cfor(i=0;i&lt;255;i++)&#123;\n    x=2;\n&#125;对于以上程序，这里x&#x3D;2是一个指令周期，执行了255次，我们这里以12Mhz的晶振为例，则我们的一个指令周期为12个时钟周期，也就是1&#x2F;12×12us也就是1us，所以以上程序就是延时0.255ms。\ncvoid Delay10ms()\n&#123;\n    unsigned char i,j,k;\n    for(i=5;i&gt;0;i--)\n    &#123;\n        for(j=0;j&lt;4;j++)\n        &#123;\n            for(k=0;k&lt;248;k++)\n        &#125;\n    &#125;\n&#125;\n再来看上面程序，这大概是一个延时10ms的延时函数，但是通过了3层for循环的时间间隔，根据计算，循环次数&#x3D;5×4×248&#x3D;4960，又因为每次循环都有两次循环判断条件（i&gt;0和i++）所以每次循环消耗两个机器周期，所以总共耗费机器周期4960×2&#x3D;9920，对于12Mhz的晶振频率，一个机器周期为1us，所以9920个机器周期就为9.92ms，加上赋值等耗费的时间大约为10ms。\nwhile和do-whilecwhile(--x);//2×x-1us如果条件成立，执行一次空语句，如果条件不成立，则执行下一条指令，对于以上程序，每次循环包括一次判断和一次运算两次指令，即两个指令周期（2us），最后一次仅有判断，则程序延时时间为：2×x-1us\ncdo//1us\n&#123;\n    while(--i);//(2×i-1us)\n&#125;while(--j);//(2×j-1us)先执行花括号里面的程序：while和空程序，do执行一次占用1us（1个指令周期）执行花括号之外的while如果为假则不执行（所以要-1）\ncvoid Delay519us()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    _nop_();//1us\n    i = 1;//1us\n    j = 255;//1us\n    do//1us\n    &#123;\n        while (--j);//2*255-1=509us\n    &#125; while (--i);//1us\n&#125;//2uscvoid Delay520us()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    i = 1;//1us\n    j = 0;//1us\n    do//1us\n    &#123;               //刚开始j=0,0--溢出为255，然后从255开始减，越等于从256开始减\n        while (--j);//2*256-1=511us\n    &#125; while (--i);//1us\n&#125;//2uscvoid Delay522us()//2us\t//522us和524us延时函数一样有误差，加起来为523us @12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    i = 2;//1us\n    j = 1;//1us\n    do//i=2，运行两边2*1=2us\n    &#123;               //先再1开始执行一遍用1us，执行第一遍的时候1-到0了\n        while (--j);//第二遍先空指令然后0到255，再从255开始减，约等于从256开始2*256-1=511us\n    &#125; while (--i);//第一遍2到1执行空程序然后在执行一遍，第二遍1到0不再往后执行了，2*2-1=3us\n&#125;//2uscvoid Delay526us()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    i = 2;//1us\n    j = 2;//1us\n    do//i=2，运行两边2*1=2us\n    &#123;               //第一遍从2开始 2*2-1=3us\n        while (--j);//第二遍约等于从256开始2*256-1=511us\n    &#125; while (--i);//第一遍2到1执行空程序然后在执行一遍，第二遍1到0不再往后执行了，3us\n&#125;//2uscvoid Delay1ms()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    i = 2;//1us\n    j = 239;//1us\n    do//i=2，运行两边2*1=2us\n    &#123;               //第一遍从239开始2*239-1=477us\n        while (--j);//第二遍约等于从256开始2*256-1=511us\n    &#125; while (--i);//第一遍2到1执行空程序然后在执行一遍，第二遍1到0不再往后执行了，3us\n&#125;//2uscvoid Delay1040us()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j;//1us\n    i = 3;//1us\n    j = 2;//1us\n    do//3*1=3us\n    &#123;               //第一遍从2开始2*(2-1)+1=3us，第二遍第三遍从256开始2*2*(256-1)+1=1022us\n        while (--j);//1022+3=1025us\n    &#125; while (--i);//2*(3-1)+1=5us\n&#125;//2uscvoid Delay132ms()//2us\t\t//@12.000MHz\n&#123;\n    unsigned char i, j, k;//1us\n    _nop_();//1us\n    i = 2;//1us\n    j = 1;//1us\n    k = 201;//1us\n    do//i=2，2us\n    &#123;\n        do              //第一遍先执行一遍循环do-while-while 1+2*(201-1)+1+1=403us然后i=1了\n        &#123;               //第二遍jk都为0了，从256开始\n            while (--k);//k执行一遍需要511us，但是j=256，所以要256*511=130816us do也要执行256遍 +256us\n        &#125; while (--j);//2*(256-1)+1=511us\n    &#125; while (--i);//2*(2-1)+1=3us\n&#125;//2us","slug":"基于51单片机的C语言延时函数","date":"2024-03-12T08:29:26.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"2618044dfa446001dfe819ad67835281","title":"基于JAVA的位运算","content":"","slug":"基于JAVA的位运算","date":"2024-03-06T15:59:50.000Z","categories_index":"","tags_index":"","author_index":"Ed-RYan"},{"id":"0c7c5c12646ceac7713a737866b0b523","title":"51单片机原理及应用","content":"51 单片机原理及应用第一章 51 单片机基础知识单片机的发展及概述微机、微处理器、单片机概念从使用角度来讲，计算机可以分为 广泛的通用计算机系统 ** 和 ** 嵌入式计算机系统**\n对于嵌入式设备，以计算机技术为基础软硬件可裁剪，可靠性高，实时性强。\n单片微型计算机（单片机） Single Chip Microcomputer\nSCM——将通用微计算机基本功能部件集成在一块芯片上构成的一种专用的微计算机系统。\n从 1976 年起，Intel 公司先后推出 MCS-48（4 位）、MCS-51（8 位）、MCS-96（16 位） 三大系列处理器，现在应用最广的是 8 位和 32 位的 ARM 处理器。\n单片机介绍：\n单片机：简称 MCU 或 EMCU （Microcontroller Unit 微控制器） （Embedded Microcontroller Unit 嵌入式微控制器）\n内部集成了 CPU，RAM，ROM，定时器，中断系统，通讯结构等一系列电脑常用的硬件功能\n单片机依靠 传感器 信息采集，依靠 CPU 处理信息，硬件设备等\n单片机相当于一个袖珍版计算机，一个芯片可以构成完整的计算机系统，但是在性能上相差甚远。\n\n例：STC89C52 单片机\n\n所属系列：51 单片机系列\n公司：STC 单机（中国的）\n位数：8 位\nRAM：512 字节（512B）\nROM：8K（Flash）（51 内核的片内程序存储器是 4KBROM）\n工作频率：12MHz\n\n为什么叫 51 单片机？\n原因是 80 年代 Intel 开发的 8051 单片机内核的统称，凡是与“8051”内核一样的单片机都称为 51 系列单片机\n单片机命名规则：\n例：STC89C52\n\n\nSTC：公司\n89：系列\nC：工作电压\nC：5.5V~3.8V\nLE：3.6V2.4V&#x2F;3.4V2.4V\n\n\n52：程序空间及 RAM 空间大小\n\n\n\n35：工作频率（可达到 35MHz）\nI：工业温度范围\nI：工业级：-40 ℃~80 ℃\nC：商业级：0 ℃~70 ℃\n\n\nDIP40：封装类型（DIP：直插）\n40：管脚数\n\n\n\n单片机功能及引脚单片机功能综述8051 是 51 单片机系统中典型产品\n\n8 位 CPU\t4KB ROM\t128 字节 RAM\t32 条 I&#x2F;O 口线\t111 条指令\t21 个专用寄存器\t2 个可编程定时&#x2F;计数器\t5 个中断源，2 个优先级\t1 个串行通信口\t……\n\n单片机封装51 单片机的芯片一般有三种封装，一种是双列直插式 DIP，另一种是方形封装，分为 PLCC 封装和 QFP 封装，他们的区别是有无底座。\n详情见 STC89C52 手册\n\n\n单片机引脚及功能标准 51 的四十个引脚\n以双列直插式封装为例，芯片有 P0~P3 四个接口，其中\n分为 4 类\n\n电源引脚 40 和接地引脚 20\n时钟引脚 XTAL1（18）和 XTAL2（19）\n并行 I&#x2F;O 口：P0、P1、P2、P3（数据在里面并行传输）\n控制引脚：复位引脚 RST（9）、ALE 地址锁存控制信号（30）、PSEN、EA外部程序存储器控制信号\n\n\nP1.0–P1.7（1~8）共八个引脚为输入输出脚\nRST&#x2F;Vp(9)为复位信号复用脚（当 RST 引脚上出现 24 个时钟周期以上的高电平时，系统即初始复位）\nP3.0–P3.7（10-17）共八个引脚为输入输出脚，每个引脚都有第二功能\n时钟 XTAL2 脚（18）：片内振荡电路的输出端\n时钟 XTAL1 脚（19）：片内振荡电路的输入端\n20 引脚：接地端\nP2.0–P2.7（21-28）共八个引脚为输入输出脚\nPSEN（29）：访问外部程序存储器时，这个引脚输出负脉冲选通信号，PC 的 16 位地址数据将出现在 P0 口和 P2 口上。当 P0 上的第八位数据被锁存后，外部程序存储器则把指令数据放在 P0 口上，由 CPU 读入并执行\nALE&#x2F;PROG（30）：访问外部程序存储器时，ALE（地址锁存）的输出用于锁存地址的低位字节，其中 ALE 在高电平期间，P0 口上出现地址信息，ALE 下降沿时 P0 口上地址信息锁存到片外地址锁存器，ALE 低电平期间 P0 口上一般出现指令和数据信息。\nEA&#x2F;Vpp（31）：程序存储器内外部选通信号线，8051 和 8751 单片机内置有 4KB 的程序存储器，当此脚为高电平时并且程序地址小于 4KB，读取内部程序指令，超过 4KB 则读取外部指令数据，当此脚为低电平时（接地）程序存储器全部使用片外的 ROM。\nP0.0-P0.7(32-39)共八个引脚为输入输出脚\n40 引脚：接+5V 电源\n\n单片机内部结构单片机即单片微型计算机，是把各种功能集成在一片芯片上构成的微型计算机\n\n中央处理器 CPU\n\n\n\n\n\n\n\n\n\n\n主要由算术&#x2F;逻辑运算器（ALU）和控制器、寄存器组成。单片机在工作时，CPU 会按先后顺序从 ROM（程序存储器）的第一个存储单元（0000H 单元）开始读取程序指令和数据，然后按指令要求对数据进行算术（如加运算）或逻辑运算（如与运算），运算结果存入 RAM（数据存储器），在此过程中，CPU 的控制器会输出相应的控制信号，以完成指定的操作。\n\n\n\n\n只读存储器 ROM（Read Only Memory）\n\n\n\n\n\n\n\n\n\n\n是一种具有存储功能的电路，断电后存储的信息不会消失。* ROM（程序存储器）类似于计算机中的硬盘* ，保存了电影、文档、音乐等文件，把电源关掉后，下次重新打开计算机，所有的文件照样还在。 ROM 主要用来存储程序和常数，用编程软件编写好的程序经编译后写入 ROM。STC89C5X 单片机中使用的 ROM 属于 Flash Memory（快闪存储器）Flash Memory 简称闪存，是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器，数据删除不是以单个字节为单位，而是以固定的区块（扇区）为单位，区块大小一般为 256KB 至 20MB。Flash Memory 是 EEPROM 的变种，两者的区别主要在于，EEPROM 能在字节水平上进行删除和重写，而大多数 Flash Memory 需要按区块擦除或重写。由于 Flash Memory 断电时仍能保存数据，且数据擦写方便，故使用非常广泛（如手机、数码相机使用的存储卡）。\n\n\n\n随机读写存储器 RAM（Read Random Access Memory）\n\n\n\n\n\n\n\n\n\n\n可以存入信息（称作写），也可以将信息取出（称作读），断电后存储的信息会全部消失。RAM（数据存储器）是单片机的数据存储空间，用来存储程序运行过程中产生的和需要的数据，跟计算机的内存是相似的概念。RAM 可分为 DRAM（动态存储器）和 SRAM（静态存储器）。 \nDRAM 的存储单元采用了 MOS 管，它利用 MOS 管的栅极电容来存储信息，由于栅极电容容量小且漏电，故栅极电容保存的信息容易消失，为了避免存储的信息丢失，必须定时给栅极电容重写信息，这种操作称为“刷新”，故 DRAM 内部要有刷新电路。DRAM 虽然要有刷新电路，但其存储单元结构简单、使用元件少、功耗低，且集成度高、单位容量价格低，因此需要大容量 RAM 的电路或电子产品（如计算机的内存条）一般采用 DRAM 作为 RAM \nSRAM 的存储单元 由具有记忆功能的触发器构成，它具有存取速度快、使用简单、不需刷新和静态功耗极低等优点，但元件数多、集成度低、运行时功耗大，单位容量价格高。因此一般需要小容量 RAM 的电路或电子产品（如单片机的 RAM）一般采用 SRAM 作为 RAM\n\n\n\n输入&#x2F;输出（I&#x2F;O）单元\n\n定时&#x2F;计数器\n\n\n\n\n\n\n\n\n\n\n定时器&#x2F;计数器是单片机内部具有计数功能的电路，可以根据需要将它设为定时器或计数器。如果要求 CPU 在一段时间（如 5ms）后执行某段程序，可让定时器&#x2F;计数器工作在定时状态，定时器&#x2F;计数器开始计时，当计到 5ms 后马上产生一个请求信号送到中断控制器，中断控制器则输出信号让 CPU 停止正在执行的程序，转而去执行 ROM 中特定的某段程序。如果让定时器&#x2F;计数器工作在计数状态，可以从单片机的 T0 或 T1 引脚输入脉冲信号，定时器&#x2F;计数器开始对输入的脉冲进行计数，当计数到某个数值（如 1000）时，马上输出一个信号送到中断控制器，让中断控制器控制 CPU 去执行 ROM 中特定的某段程序（如让 P0.0 引脚输出低电平点亮外接 LED 灯的程序）。\n\n\n\n串行口\n\n\n\n\n\n\n\n\n\n\n 串行通信口 是单片机与外部设备进行串行通信的接口。当单片机要将数据传送给外部设备时，可以通过串行通信口将数据由 TXD 端输出；外部设备送来的数据可以从 RXD 端输入，通过串行通信口将数据送入单片机。串行是指数据传递的一种方式，串行传递数据时，数据是一位一位传送的。\n\n\n\n等等\n\n\n内部结构如下图所示\n\n\n\n中央处理器CPU主要由算术&#x2F;逻辑运算器（ALU）和控制器、寄存器组成。\n算术逻辑单元ALU，主要由一个加法器，两个 8 位暂存器（TMP1 和 TMP2）和布尔处理器组成。\n定时控制部件起到控制器的作用，由 定时控制逻辑、指令寄存器 和 振荡器 等电路组成\n\n指令寄存器（IR Instruction Register）用于存放从程序存储器中读取的指令码\n定时控制逻辑用于对指令寄存器中的指令进行译码并在晶振的配合下产生执行指令所需的时序脉冲，从而完成指令\n\n专用寄存器组专用寄存器组用于指示当前要执行指令的内存地址、存放操作数和指示指令执行后的状态，包括程序计数器 PC、累加器 A、程序状态字 PSW（Program Status Word）、堆栈指示器 SP 寄存器、数据指针 DPTR 和通用寄存器 B\n\n程序计数器（PC）\n是一个 16 位 2 进制的程序地址寄存器（216&#x3D;65536字节&#x3D;64KB），用于存放下一条要执行指令的地址，引导程序运行，执行完后自动加一，以便指向下一条要执行的指令。复位时PC值为0，程序从0000H地址开始运行。可以说 CPU 就是靠 PC 指针来实现程序的执行\n\n\n累加器 A\n累加器 A 是程序中最常用的 8 位 2 进制特殊功能寄存器，用于存放操作数和运算结果。在 CPU 执行运算前，把两个操作数中的一个通常在累加器 A 当中，运算完成后便把结果存放在累加器 A 当中，可以说累加器 A 是使用最频繁的寄存器\n\n\n程序状态字 PSW\n\n是一个 8 位 2 进制寄存器，用于存放指令执行后有关 CPU 的状态\nD7:Cy：进位标志位“位累加器”\nD6：AC：辅助进位标志位\nD5：F0：用户通用状态标志\nD4、D3：RS1、RS0：工作寄存器组选择控制位\nD2：OV：溢出标志\nD1：保留位\nD0：P：奇偶标志位（A中有奇数个“1”则P置1否则清0）\n\n\n\n\n堆栈指针 SP\n堆栈是一种数据结构，SP 是一个 8 位寄存器，指示了栈顶在内部 RAM 的位置，作用是保护断点地址和保护现场数据。对于堆栈指示器，有两种操作有入栈（PUSH）和出栈（POP）。入栈时SP自动加1，出栈操作后SP自动减1，因此SP内容始终为栈顶地址。\n通常堆栈区设在30H-7FH范围内，复位后SP位置为07H\n\n\n数据指针 DPTR\n是一个 16 位寄存器，由 2 个 8 位寄存器 DPH 和 DPL 组成（0000H-FFFFH），其中 DPH (RAM)为高 8 位，DPL(ROM) 为低 8 位，既可以存放数据存储器也可以存放程序存储器的地址。可被指令直接修改，变更数据的地址。\n\n\n通用寄存器 B\n是专门为乘法和除法而设置的寄存器，是一个 2 进制 8 位寄存器在乘法或除法运算之前用于存放乘数或除数，运算后用于存放乘积的高 8 为或除法的余数。\n\n\n\n存储器结构\nMCS-51 单片机存储器的特点是将数据存储器和程序存储器分开编址，并有各自的寻址方式和寻址单元。\n51单片机存储器的结构为哈佛结构，程序存储器和数据存储器相互独立，分别寻址，相互不冲突\n存储器在物理上划分为 4 个单元：片内 ROM、片外 ROM、片内 RAM、片外 RAM\n\n程序存储器 ROM\n编程人员编写的程序存放在程序存储器中，单片机重启后，PC 的内容为 0000H，所以系统从 0000H 开始执行程序，但是考虑到中断系统，用户程序一般不从 0000H 开始存放，因为接下来有一段程序区要用于存放中断向量表，所以用户不能占用，要求分配地址如下 \n用户一般从 0030H 处开始，而在 0000H 处放置一条跳转指令，这样复位后从 0000H 处跳转至用户的主程序。\n此外，还需要看引脚&#x2F;EA 的状态\n\n&#x2F;EA 接地：程序存储器全部使用片外 ROM\n&#x2F;EA 接高电平：CPU 先从内部程序存储器中读取程序，当 PC 超过内部 ROM 容量时转外部程序存储器读取程序\n\n片内 RAM数据存储器MCU-51 的 RAM 存储器共有 128 字节，可分为 4 个区域，分别是 特殊功能寄存器区、用户区、位寻址区、工作寄存器区。\n其中，00H-7FH为内部RAM，包括普通RAM区，位寻址区，工作寄存器区。位寻址区可以进行位寻址，而其它区只能字节寻址。80H-FFH为专用寄存器。\n工作寄存器区从 00H-1FH 为 4 组工作寄存器区，每组占用 8 个 RAM 字节，记为 R0-R7。工作寄存器组的选择由程序状态字 PSW 中的 RS1-RS0 位确定\n\n位寻址区从 20H-2FH 为位寻址区，16 个字节的的 128 位可以单独操作 ，20H2FH，不仅可以字节寻址，8 个字节的每一位都可以位寻址 ；               位地址范围 00H7FH, 地址范围 20H~2FH               位地址表示方法：位地址，字节地址.位               位地址与字节地址的转换关系 ： 位地址 &#x3D;(字节地址-20H)*8+Di 的 i 值\n\n用户区用户区共 80 个 RAM 单元，用于存放用户数据或者作为堆栈区，其中的数据存储区按字节存取\n特殊功能寄存器(SFR)存放在高128字节中80H-FFH\n对于CPU内的SFR，用户不需要考虑，在进行C51编程时，编译器会自动分配CPU的资源。\n\n\n\n寄存器符号\t地 址\t寄存器名称\n\nCPU\n\nACC\tE0H\t累加器\nB\tF0H\t乘法寄存器\nPSW\tD0H\t程序状态字\nSP\t81H\t堆栈指针\nDPL\t82H\t数据存储器指针（低 8 位）\nDPH\t83H\t数据存储器指针（高 8 位）\n\n\n中断系统\n\nIE\tA8H\t中断允许控制器\nIP\tD8H\t中断优先级控制器\n\n\n并行口\n\nP0\t80H\t通道 0\nP1\t90H\t通道 1\nP2\tA0H\t通道 2\nP3\tB0H\t通道 3\n\n\n串行口\n\nPCON\t87H\t电源控制和波特率选择\nSCON\t98H\t串行口控制器\nSBUF\t99H\t串行数据缓冲器\n\n\n定时&#x2F;计数器\n\nTCON\t88H\t定时控制器\nTMOD\t89H\t定时工作模式选择\nTL0\t8AH\t定时器 0 低 8 位\nTL1\t8BH\t定时器 1 低 8 位\nTH0\t8CH\t定时器 0 高 8 位\nTH1\t8DH\t定时器 1 高 8 位\n\n\n\nI&#x2F;O 口结构并行 I&#x2F;O 口8051有4个并行I&#x2F;O端口，分别为P0、P1、P2、 P3，每个端口都有双向I&#x2F;O功能，可以从端口读 取数据和向端口写入数据\n\n\n\n串行 I&#x2F;O 口8051具有一个全双工的可编程串行口，可以实 现８位并行数据的串行发送和接收。在使用串 行口之前必须对其初始化，即对PCON及SCON 寄存器进行设置\n定时&#x2F;计数器8015 有两个 16 位定时&#x2F;计数器 T0 和 T1，分别与两个 8 位寄存器 TL0、TH0 及 TL1、TH1 对应\n8051 的定时&#x2F;计数器可以工作在定时方式和计数方式\n定时方式：实现对单片机内部的时钟冒充你或分频后的脉冲进行计数\n计数方式：实现对外部脉冲的计数。\n中断系统程序执行过程中，有时需停下正在执行的工作而去执行一些其他重要工作，并在执行完后返回到刚刚执行的程序中继续执行，这就是中断的一个过程。\n8051 有 5 个中断源，分别为 2 个外部中断 INT0 和 INT1，两个定时器中断 T0 和 T1 和一个串行中断。两个中断优先级控制可实现中断服务嵌套。\n中断的控制由中断允许寄存器 IE 和中断优先寄存器 IP 实现\n51单片机的工作方式51单片机有两种工作方式，分别是复位工作方式和程序执行方式\n复位方式当RST引脚为高电平，且有效时间持续2个机 器周期以上，才能复位\n\n常用的复位方式有上电复位（冷启动）和按键复位（热启动）\n主要功能是把PC初始化为0000H，使单片机从 0000H单元开始执行程序；\n复位有效期间，ALE和PSEN引脚均为高电平， 且内部RAM状态不受影响\n\n程序执行方式连续执行方式 连续执行方式是单片机执行的基 本工作方式，所要执行的代码放在程序存储器 ROM中（可以是片内或片外），CPU不断地从 程序存储器中取指令、译码并执行。\n单步执行方式 程序的执行处于外加脉冲（通常 用一个按键产生）的控制下，一般利用中断来 实现程序的单步执行\n第二章 Keil C51 软件入门与调试使用单片机需要学习计算机语言，可以采用汇编语言和 C 语言（C51），由于汇编语言晦涩难懂，所以大多数选择 C 语言，我们这里以 C 语言为例，学习 KeilC51 软件的使用，同时使用 Proteus 软件进行仿真。\nProtues 仿真软件与 Keil 联合调试并行 I&#x2F;O 端口51 单片机的中断系统51 单片机定时&#x2F;计数器51 单片机串行通信接口键盘输入输出设备单片机系统拓展常用外围接口芯片常用数据传输接口","slug":"51单片机基础","date":"2024-02-27T15:18:00.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"3a5ead127caa80ef0aaf607575d6dc9c","title":"基于Java的排序算法","content":"基于 Java 的排序算法八大排序，三大查找是数据结构基础知识点，今天来学习一下排序算法\n所谓排序，就是整理表中的元素，使表中的元素按照一定的关键字依次递增或者递减的顺序排列\n关于排序的稳定性： 对于排序的关键字，当待排序的 排序关键字 各不相同时，排序结果唯一，若存在多个关键字相同的排序元素，则不一定唯一，这时，经过排序后这些具有相同关键字的元素之间相对次序不变，则称排序方法是稳定的，否则，若具有相同关键字的排序元素之间的相对次序发生了变化，则称排序方法是不稳定的。\n有关内排序和外排序之间的区别： 在排序过程中整个表都是放在内存中处理，排序时不涉及内、外存数据交换，称之为内排序，否则为外排序\n排序算法之间的关系如下\n\n以下是他们的性能比较\n\n我们从上往下依次学习他们\n直接插入排序直接插入排序是指将一个待排序的元素插入到已经排好序的有序序列当中去，直到插完所有元素为止，步骤如下\n\n假设第一个元素已经排好序\n依次取出还需要进行排序的下一个元素，设为待插入元素，在已经排好序的元素中从后向前扫描，如果该元素（已经排序）大于待插入元素，则后移\n重复步骤 2，直至找到已排序的元素小于或者等于待排序元素的位置，插入元素\n重复 2,3，完成排序\n\n直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。\n以下是代码实现\njavaimport java.util.*;\npublic static package com.paixu;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class ZhijieCharu &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;请输入元素的个数&quot;);\n        int n = sc.nextInt();\n        int arr[] = new int [n];\n        System.out.println(&quot;请依次输入元素&quot;);\n        for(int i=0;i&lt;n;i++) &#123;\n            arr[i]=sc.nextInt();\n        &#125;\n        //以上就构建完我们要排序的原始序列，接下来我们要进行排序\n        for(int i=1;i&lt;n;i++) &#123;//假设第一个元素是已经排好序的，外循环是待插入的元素\n            int temp = arr[i];\n            for(int j=i-1;j&gt;=0;j--) &#123;//从最后一个元素开始比较\n                if(arr[j]&gt;temp) &#123;\n                    arr[j+1]=arr[j];\n                    arr[j]=temp;\n                &#125;\n                else break;\n            &#125;\n        &#125;\n        for(int x:arr) &#123;//使用foreach输出\n            System.out.print(x+&quot; &quot;);\n        &#125;\n    &#125;\n&#125;运行结果\n\n直接插入排序的总结：\n\n初始元素表越接近有序，直接插入排序的算法时间效率就越高\n平均时间复杂度为O（n2）\n空间复杂度为O（1），是一种稳定的排序算法\n\n希尔插入排序（Shell排序）希尔插入排序是一种插入排序，是直接插入排序的一种高效的改进版本，但是是一种非稳定的算法\n希尔排序充分利用了插入排序的两个特点\n\n数据规模较小时非常高效\n给定数据已经排好序时时间复杂度为O（n）\n\n希尔排序的基本思想：每次把数据分成若干块，来使用插入排序，之后在这若干块排好序的情况下把他们合成大一点的小块，继续使用插入排序，\ntxtpackage com.paixu;\nimport java.util.*;\npublic class ShellSort &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;9,8,7,6,5,4,3,2,1,0&#125;;\n        int n = arr.length;\n        for(int gap=n/2;gap&gt;0;gap/=2) &#123;\n            for(int i=gap;i&lt;n;i++) &#123;\n                int temp = arr[i];\n                int j=i;\n                while(j&gt;=gap&amp;&amp;arr[j-gap]&gt;temp) &#123;\n                    arr[j]=arr[j-gap];\n                    j-=gap;\n                &#125;\n                arr[j]=temp;\n            &#125;\n        &#125;\n        for(int i:arr)System.out.print(i+&quot; &quot;);\n    &#125;\n    \n&#125;\n选择排序选择排序是一种简单直观的排序算法，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\njavapackage com.paixu;\nimport java.util.Scanner;\npublic class SelcetSort &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;9,8,7,6,5,4,3,2,1,0&#125;;\n        int flag=0;\n        while(flag&lt;arr.length) &#123;\n            int min=Integer.MAX_VALUE;\n            for(int i=flag;i&lt;arr.length;i++) &#123;\n                if(arr[i]&lt;min) &#123;\n                    int temp = arr[i];\n                    arr[i]=arr[flag];\n                    arr[flag]=temp;\n                    min=arr[i];\n                &#125;\n            &#125;\n            flag++;\n        &#125;\n        for(int i:arr)System.out.print(i+&quot; &quot;);\n    &#125;\n&#125;\n冒泡排序冒泡排序是一种简单的交换排序算法，以升序排序为例，其核心思想是：\n\n从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换。\n轮到下一组相邻元素，执行同样的比较操作，再找下一组，直到没有相邻元素可比较为止，此时最后的元素应是最大的数。\n除了每次排序得到的最后一个元素，对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。\n\njavapackage com.paixu;\nimport java.util.Scanner;\npublic class BubbleSort &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;9,8,7,6,5,4,3,2,1,0&#125;;\n        for(int i=0;i&lt;arr.length;i++) &#123;\n            for(int j=i+1;j&lt;arr.length;j++) &#123;\n                if(arr[i]&gt;arr[j]) &#123;\n                    int temp = arr[i];\n                    arr[i]=arr[j];\n                    arr[j]=temp;\n                &#125;\n            &#125;\n        &#125;\n        for(int i:arr) &#123;\n            System.out.print(i+&quot; &quot;);\n        &#125;\n        \n    &#125;\n\n&#125;\n","slug":"基于Java的排序算法","date":"2024-02-17T12:59:25.000Z","categories_index":"算法","tags_index":"Java","author_index":"Ed-RYan"},{"id":"303cf45e0ace07b44a01a04e2f8411a1","title":"斐波那契数列代码实现","content":"斐波那契数列斐波那契数列（Fibonacci sequence），又称黄金分割数列 ，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称“兔子数列”，其数值为：1、1、2、3、5、8、13、21、34……在数学上，这一数列以如下递推的方法定z义：F(0)&#x3D;1，F(1)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）。\n对于算法的学习而言，有很多题目会从斐波那契数列来考验编程者的逻辑思维。\nJava代码实现用递归的方式实现javapackage com.zhishidian;\n\npublic class Fibonacci &#123;\n    public static void main(String[] args)&#123;\n        for(int i=1;i&lt;50;i++) &#123;\n            System.out.printf(&quot;Fibonacci of %d is :%d\\n&quot;,i,f(i));\n        &#125;\n    &#125;\n    //定义一个求解斐波那契数列的方法\n    public static int f(int i)&#123;\n        if(i==1||i==0)return i;\n        else return f(i-1)+f(i-2);\n    &#125;\n&#125;\n使用普通循环方法实现javapackage com.zhishidian;\npublic class FibonacciXUNHUAN &#123;\n    public static void main(String[] args) &#123;\n        //定义三个变量分别用来存储三个斐波那契数列的数值\n        int f1=1;\n        int f2=1;\n        int f3;\n        System.out.printf(&quot;Fibonacci of %d is %d\\nFibonacci of %d is %d\\n&quot;,1,f1,2,f2);\n        for(int i=3;i&lt;=50;i++) &#123;\n            f3=f2+f1;\n            System.out.printf(&quot;Fibonacci of %d is %d\\n&quot;,i,f3);\n            f1=f2;\n            f2=f3;\n        &#125;\n    &#125;\n&#125;\n使用数组方式实现javapackage com.zhishidian;\nimport java.util.Arrays;\npublic class FibonacciSHUZU &#123;\n    public static void main(String[] args) &#123;\n        int []arr = new int[50];//new一个50个数的数组，准备输出50个斐波那契数列\n        arr[0]=1;\n        arr[1]=1;\n        for(int i=2;i&lt;arr.length;i++) &#123;\n            arr[i]=arr[i-1]+arr[i-2];\n        &#125;\n        String s = Arrays.toString(arr);\n        System.out.println(&quot;Fibonacci:&quot;+s);\n    &#125;\n&#125;使用其他方式实现当然还有许多可以优化并且巧妙的方式可以实现斐波那契数列，今后我们有时间再补充\n使用斐波那契数列解题下面给出一些常见的考察到斐波那契数列知识点的常见题目\n","slug":"斐波那契数列代码实现","date":"2024-02-11T13:33:52.000Z","categories_index":"算法","tags_index":"Java","author_index":"Ed-RYan"},{"id":"746936c330f59bbc3420fd4970ee32dd","title":"51单片机-模块化编程","content":"模块化编程传统方式编程：所有的函数均存放在 main.c 文件里，使用模块较多，则一个文件会包含很多代码，不方便代码的组织和管理，而且在一定程度上会影响编程者的思路\n模块化编程：把各个模块的代码放在不同的.c 文件里，在.h 文件里提供外部可调用函数的声明，其他.c 文件想使用其中的代码只需要#include “XXX.h” 文件即可。使用模块化编程可极大提高代码的可阅读、可维护、可移植性。\n.c文件所包含的是函数和变量的定义\n.h文件包含的是可被外部调用的函数和函数的声明\n下面流程框图是函数模块化的具体操作。\n\n\n\n在.c 文件中直接定义函数\n在.h 函数中声明函数\n在主函数中#include\n\n以上是Delay函数的模块化操作，下面我来演示一下我们在使用数码管时调用的数码管函数模块化\n可以看到下列代码的Delay函数和Nixie函数都是定义在main.c中的，我们要把Nixie函数模块化\n\n\n先创建一个新文件，命名和函数名相同即可\n\n然后将函数体剪切到刚刚创建的Nixie文件中（注意，由于函数中使用到了P0接口，P0接口是定义在头文件REGX52.H中的，我们需要在.c文件中includeREGX52.h头文件）\n\n\n接着以相同的步骤，创建一个后缀为.h的头文件，命名和函数名相同\n\n\n在其中声明我们的函数\n\n\n最后在主函数头文件中include一下，就可以在main.c的函数体中使用了\n\n","slug":"51单片机-模块化编程","date":"2024-02-03T04:25:17.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"72468961c9322689b5ba89f282674665","title":"51单片机数码管","content":"数码管数码管在开发板的左上角位置，是一种简单廉价的显示器，由多个发光二极管封装在一起组成的“8”字型器件\n数码管分为共阳极和共阴极类型\n根据开发板原理图如下\n\n数码管和 138 译码器是联动使用的，根据原理图可知，138 译码器的 P2_4、P2_3、P2_2 组成的 CBA 二进制数，输出端对应的 LED 控制着点亮数码管的位置，数码管所显示的信息有 0、1、2、3、4、5、6、7、8、9，根据原理图可得下表\n\n\n\n数码管显示\n十六进制代码\n\n\n\n0\n0x3F\n\n\n1\n0x06\n\n\n2\n0x5B\n\n\n3\n0x4F\n\n\n4\n0x66\n\n\n5\n0x6D\n\n\n6\n0x7D\n\n\n7\n0x07\n\n\n8\n0x7F\n\n\n9\n0x6F\n\n\n这里我们可以构造一个便捷使用数码管的函数\ncunsigned char NixieTable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;;\nvoid Nixie(unsigned char Location,Number)\n&#123;\n    switch(Location)\n    &#123;\n            case 1:P2_4=1;P2_3=1;P2_2=1;break;//千万不要忘记 break，否则数码管会一直显示在第八位\n            case 2:P2_4=1;P2_3=1;P2_2=0;break;\n            case 3:P2_4=1;P2_3=0;P2_2=1;break;\n            case 4:P2_4=1;P2_3=0;P2_2=0;break;\n            case 5:P2_4=0;P2_3=1;P2_2=1;break;\n            case 6:P2_4=0;P2_3=1;P2_2=0;break;\n            case 7:P2_4=0;P2_3=0;P2_2=1;break;\n            case 8:P2_4=0;P2_3=0;P2_2=0;break;\n    &#125;\n    P0=NixieTable[Number];\n&#125;\n    下面给出一个结合for循环使用数码管的案例\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned int xms)\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nunsigned char NixieTable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;;\nvoid Nixie(unsigned char Location,Number)\n&#123;\n    switch(Location)\n    &#123;\n            case 1:P2_4=1;P2_3=1;P2_2=1;break;\n            case 2:P2_4=1;P2_3=1;P2_2=0;break;\n            case 3:P2_4=1;P2_3=0;P2_2=1;break;\n            case 4:P2_4=1;P2_3=0;P2_2=0;break;\n            case 5:P2_4=0;P2_3=1;P2_2=1;break;\n            case 6:P2_4=0;P2_3=1;P2_2=0;break;\n            case 7:P2_4=0;P2_3=0;P2_2=1;break;\n            case 8:P2_4=0;P2_3=0;P2_2=0;break;\n    &#125;\n    P0=NixieTable[Number];\n&#125;\nvoid main()\n&#123;\n    int i;//创建循环变量i\n    while(1)\n    &#123;\n        for(i=1;i&lt;=8;i++)//一共有八个数码管，创建8次循环\n        &#123;\n            Nixie(i,i);//每次循环中显示第i个数码管上显示i\n            Delay(500);//延时500ms\n        &#125;\n    &#125;\n&#125;","slug":"51单片机数码管","date":"2024-02-02T16:09:03.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"b47f8004de5de2e7f095c07f5432799b","title":"51单片机独立按键模块","content":"51 单片机的独立按键模块这篇文章我们来学习 51 单片机开发板的独立按键模块\n根据开发板原理图，独立按键模块的接口如下图所示\n\n\n如图所示，四个独立按键都是检测低电平，且 K1 由 P3_1 控制，K2 由 P3_0 控制，K3、K4 由 P3_2、P3_3 控制\n按键的抖动对于机械开关，机械触点断开闭合时，由于机械开关触点的弹性作用，一个开关在闭合的时候不会马上稳定的接通，在断开的时候也不会一下子就断开，在闭合和断开的那一瞬间会伴随一连串的抖动\n\n\n对于按键抖动，一般有两种方法可以消除，一种是 硬件消抖，通过按键输出通道上添加去抖动电路（如单稳态电路或者滤波电路等（详情见模拟电路））从根本上避免抖动发生，但是由于增加了硬件电路，会增加一定的成本和电路的复杂程度。还有一种最常用的消抖方法是 软件消抖，在检测到按键按下时，延迟一定的时间（5-10 毫秒甚至 20 毫秒）等抖动期过去后重新检测按键的状态，如果在延迟期间按键保持闭合状态，则认为是有效的按键按下，如果不是，则有可能是一个抖动的干扰信号，按键的释放过程也类似，检测到按键松开时，延迟一定时间（5-10 毫秒）等抖动期过去后结束。\ncvoid main()  //这里我们只给出主函数，延时函数等模块的代码自行添加\n&#123;\n    while(1)\n    &#123;\n        if(P3_1==0)//判断 K1 按下\n        &#123;\n            Delay(20);//延时 20ms 过滤掉抖动\n            while(P3_1==0);//如果按键一直按下，会在这个循环里一直循环，松手后会跳出循环\n            Delay(20);//过滤掉松手后的抖动\n        &#125;\n    &#125;\n&#125;独立按键使用示例独立按键其实是一个非常简单的模块，主要是在编写程序的时候会用到大量的 IF 语句，比较考验编程者的逻辑思维能力，下面给出一段调用独立按键模块的示例代码和注释，方便大家学习\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()\n&#123;\n    while(1)\n    &#123;\n        if(P3_1==0)//判断 K1 按下\n        &#123;\n            Delay(20);//延时 20ms 过滤掉抖动\n            while(P3_1==0);//如果按键一直按下，会在这个循环里一直循环，松手后会跳出循环\n            Delay(20);//过滤掉松手后的抖动\n             P2=~P2;//松手后 LED 模块会全部亮起或者全部熄灭\n        &#125;\n    &#125;\n&#125;","slug":"51单片机独立按键模块","date":"2024-02-02T14:37:25.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"0e7c93a805541486cdd5b2caca119a40","title":"51单片机常用模块驱动代码","content":"51单片机常用模块驱动代码延时代码Delay()在STC-ISP中，我们可以根据自己开发板的型号和系统的频率来自动生成对应时间的延时代码，需要多长时间我们就选择对应的定时长度。\n\n\n但是生成的延时代码只能对应一个延时时间，所以我们需要自己构造一个函数，来延时我们想要延时的时间，我们可观察到的时间单位一般是以秒或者毫秒为单位的，如果是以微秒为的单位，开发板的变化可能以肉眼观察不到，所以我们自动生成一个一毫秒的延时代码，将自动生成的代码复制到Keil中\n\n\n已知根据开发板的配置生成的一毫秒的延时函数，即一次这样的do-while循环会延时1毫秒，所以我们在里面构造一个while函数，定义一个xms形参，来定义我们想要延时的毫秒数，修改后的Delay函数如下\ncvoid Delay(unsigned char xms)\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;这样，在开发板程序中，一个Delay（xms）函数就相当于延时了xms毫秒\n下面是一个使用示例\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned char xms)\t//@12.000MHz\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()\n&#123;\n    while(1)\n    &#123;\n        P2_0=~P2_0;\n        Delay(500);\n    &#125;\n&#125;这段代码的实现功能是让开发板上LED模块的D1灯以500ms的频率闪烁\n","slug":"51单片机常用模块驱动代码","date":"2024-02-02T09:45:18.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"455781cc215699651b5e7dac0955faf1","title":"使用51单片机控制LED模块","content":"用 51 单片机控制单片机上的 LEDLED 介绍：\n\n中文名：发光二极管\n英文名：Light Emitting Diode\n简称 LED\n用途：照明、广告灯、指引灯、屏幕\n\n\n\n由开发板原理图我们可以知道，开发板上的 LED 模块（D1 到 D8 八个横向的 LED 灯）是由 MCU 主板上的 P20~P27 八个引脚控制，我们可以在 Keil 工程中编程控制\n且 8 个 LED 是由低电平控制，即引脚 0 为亮，1 为灭\n整体控制以下代码控制八个 LED 灯全亮\nc#include &lt;REGX52.H&gt;\n\nvoid main()\n&#123;\n    P2=0x00;  // 0000 0000\n    while(1)\n    &#123;\n        \n    &#125;\n&#125;注意，控制 P2 的八个引脚，P27~P20，可以用 P2 表示一个八位的二进制数，即两位十六进制数，如以上代码\n一般的单片机程序都会在主程序后面加上 while(1)的死循环, 指代码不再向下执行，主要是为了防止程序跑飞，让程序一直保持在我们需要的情况下。\n\n由于 C 语言不能直接表示二进制数，我们一般通过十六进制或者十进制来表示 P2 端口的状态, P20 到 P27 依次控制 D1 到 D8,\n单独控制我们也可以用 P2_0, P2_1, P2_2, P2_3……P2_7 来单独控制各个 LED 灯的状态\nc#include &lt;REGX52.H&gt;\n\nvoid main()\n&#123;\n    P2_0=0;\n    P2_1=1;\n    P2_2=0;\n    P2_3=1;\n    P2_4=0;\n    P2_5=1;\n    P2_6=0;\n    P2_7=1;\n    \n    while(1)\n    &#123;\n        \n    &#125;\n&#125;控制 LED 闪烁效果为了控制 LED 闪烁，我们需要用到延时函数，有关延时函数的介绍我们放到另一篇文章：51 单片机常用模块的驱动代码 讲解。\n一下是示例代码和注释\nc#include &lt;REGX52.H&gt;\n\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\n\nvoid main()  //主函数\n&#123;\n    \n    while(1)\n    &#123;\n        P2_1=0; //LED 灯 D2 亮\n        Delay(500); //延时 500ms\n        P2_1=1;\t//LED 灯 D2 灭  \n        Delay(500);  //延时 500ms\n    &#125;\n&#125;这段代码实现了 D2 灯的闪烁，当然 调整延时时间也可以控制闪烁的频率\n实现流水灯效果的几种方法最简单的暴力写法第一种方法毫无技术性可言，就是对每个灯的接口挨个编写，但是这种方法写起来既费时又费力，不建议大家写程序时使用这种写法。但是初学者还是从这种写法开始写起：我们直接看下列代码\nc#include &lt;REGX52.H&gt;\n\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\n\nvoid main()  //主函数\n&#123;\n    \n    while(1)\n    &#123;\n        P2_0=0;\n        Delay(500);\n        P2_0=1;\n        P2_1=0;\n        Delay(500);\n        P2_1=1;\n        P2_2=0;\n        Delay(500);\n        P2_2=1;\n        P2_3=0;\n        Delay(500);\n        P2_3=1;\n        P2_4=0;\n        Delay(500);\n        P2_4=1;\n        P2_5=0;\n        Delay(500);\n        P2_5=1;\n        P2_6=0;\n        Delay(500);\n        P2_6=1;\n        P2_7=0;\n        Delay(500);\n        P2_7=1;\n    &#125;\n&#125;个人不是很建议在实际应用中使用这种写法。\n移位法为了实现流水灯效果，就是让 P2 接口的赋值的二进制数 11111110 当中的 0 从右向左或者从左向右依次移位，这里我们可以用到位运算符 &lt;&lt;或者&gt; &gt; 联合循环语句实现\n\n\nc#include &lt;REGX52.H&gt;\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()  //主函数\n&#123;\n    char temp = 0x01;//创建一个临时变量 temp\n    while(1)\n    &#123;\n        if(!temp)temp = 0x01;//判断临时变量的状态，如果临时变量为 0 了，把他重新赋值为 0000 0001\n        P2=~temp; //让 P2 对 temp 取反，即 P2 = 1111 1110\n        Delay(500);//延时 500ms\n        temp=temp&lt;&lt;1;//temp 向左移位，例如第一次移位后 temp 为 0000 0010，P2 为 1111 1101\n    &#125;\n&#125;权表示法让 LED 模块实现流水灯效果，就是让 P2 的值依次移位，像上一个方法一样，P2 &#x3D; 1111 1110——-1111 1101——–1111 1011——–1111 0111&amp;…………0111 1111, 这是二进制数的变换，我们把他按权展开，如下图所示\n\n\nc#include &lt;REGX52.H&gt;\n#include &lt;math.h&gt;//调用数学函数，为了使用 2 的 n 次方\nvoid Delay(unsigned int xms) //自定义延时函数\n&#123;\n    unsigned char i, j;\n    while(xms--)\n    &#123;\n        i = 2;\n        j = 239;\n        do\n        &#123;\n            while (--j);\n        &#125; while (--i);\n    &#125;\n&#125;\nvoid main()  //主函数\n&#123;\n    int i=0;\n    while(1)\n    &#123;\n        for(i=0;i&lt;8;i++)\n        &#123;\n            P2=255-pow(2,i);\n            Delay(500);\n        &#125;\n    &#125;\n&#125;代码的逻辑思维展现在刚刚上面的流程图上，可以理解一下上面的流程图再编写代码\n结语以上就是 51 单片机中 LED 灯的基本控制方法，其实 LED 灯还可以联合 51 单片机的其他模块，如矩阵键盘、独立键盘、数码管等模块，期待在今后的学习中能够不断探索这些模块之间的应用。\n","slug":"使用51单片机控制LED模块","date":"2024-02-02T09:37:36.000Z","categories_index":"51单片机","tags_index":"电子","author_index":"Ed-RYan"},{"id":"63c2215d1bf95a785134886f25737c76","title":"AltiumDesigner入门","content":"Altium Designer入门本片文章的学习方向：\n\nAD软件\n电子设计\n原理图\n原理图库\n原理图绘制\n\n\nPCB设计\nPCB布局\nPCB布线\n\n\n\n\n\n学习方法：\n\n软件\n软件操作多练习\n牢记快捷键\n\n\n设计1.##软件中英文切换打开软件后，软件激活：可以在网络上搜所AltiumDesigner学生权益，通过学校邮箱注册学生版本，当然，没有学校邮箱的也可以选择网络上的激活方法进行激活由于刚安装软件，菜单全部都是英文状态，这个时候我们可以打开菜单栏右上角的设置图标，进入设置页面后在勾选使用本地资源，然后重新启动软件，这个时候我们可以看到整个界面都成为中文界面了\n\nAD工程的组成和创建一个PCB工程包含了原理图库、原理图、PCB库、PCB、生产文件等。以下演示创建一个PCB工程的操作首先创建一个项目在界面中选一个默认的PCB的demo，起一个合适的名字和选择合适路径后生成然后创建我们的PCB元件库和原理图库、原理图（有些版本可能会自动生成） 我们的工程就包含了一下四个文件：\n元件库及电阻容模型的创建","slug":"AltiumDesigner入门","date":"2024-01-29T15:31:08.000Z","categories_index":"电子设计","tags_index":"电子","author_index":"Ed-RYan"},{"id":"96563376ad7b138d66798614753928b1","title":"Java数据结构和算法","content":"Java 数据结构和算法数据结构和算法的重要性：\n\n算法是程序的灵魂，程序在进行海量的数据计算时，优秀的算法可以让程序保持高速运算\n程序会使用 内存计算框架 和 缓存技术 来优化程序\n\n数据结构和算法的关系\n\n数据（data）结构（structure）是研究组织数据方式的学科\n程序 &#x3D; 数据结构＋算法\n数据结构是算法的基础\n\n数据结构包括：线性结构 和 非线性结构线性结构\n线性结构是最常用的数据结构，特点是数据元素之间存在一对一的线性关系\n线性结构有两种不同的存储结构，即 顺序存储结构 和 链式存储结构。\n顺序存储方式即为顺序表，顺序表中存储元素是连续的（地址是连续的，如 数组）\n链式存储方式的线性表称为 链表，链表中存储元素不一定是连续的，元素节点中存放数据元素和相邻元素的地址信息。\n线性结构常见的有：数组、队列、链表、栈\n\n非线性结构\n非线性结构包括：二维数组、多维数组、广义表、树结构、图结构\n\n稀疏数组和队列稀疏数组（sparsearray 数组）二维数组默认值为 0，有时候使用二维数组会有大部分元素为 0，即有很多无用数据，这个时候可以使用稀疏数组。\n定义：当一个数组大部分元素为 0，或为同一个值的数组，可以使用稀疏数组来保存该数组。\n处理方法\n\n记录 数组有几行几列，有多少不同数值\n把记录不同数值的元素的行列值存储在另一个小规模数组中，从而 缩小程序规模。\n\n \n这里拓展数组的定义和遍历方式\n定义方式：\njavaint Arr1[]=new int [5];//定义普通一维数组(静态初始化)\n//也可以直接赋值(动态初始化)\nint Arr2[]=&#123;1,2,3,4,5&#125;;\n//以下是二维数组定义\nint Arr3[][]=new int[3][4];\nint Arr4[3][4]=&lt;!--swig￼0--&gt;;常用遍历方式：\njavafor(int i=0;i&lt;Arr2.length;i++)&#123;\n    System.out.print(Arr2[i]+&quot;\\t&quot;);\n&#125;//一位数组遍历\nfor(int i=0;i&lt;Arr3.length;i++)&#123;\n    for(int j=0;j&lt;Arr3[i].length;j++)&#123;\n        System.out.print(Arr3[i][j]+&quot;\\t&quot;);\n    &#125;\n    System.out.println();\n&#125;//二维数组遍历增强遍历方式（foreach 遍历）\njavafor(int num:Arr2)&#123;\n    System.out.println(num+&quot;\\t&quot;);\n&#125;//一维数组的 foreach 遍历\nfor(int[]row:Arr4)&#123;\n    for(int data:row)&#123;\n        System.out.print(data+&quot;\\t&quot;)\n    &#125;\n&#125;拓展完数组的定义和遍历方式，我们接下来用代码实现稀疏数组和原始数组的转换：\njavapublic class SparseArry&#123;\n    public static void main(String[] args)&#123;\n        //首先创建一个原始的数组\n        int Arr1[][]=new int [10][10];\n        Arr1[3][4]=1;\n        Arr1[5][6]=2;\n        Arr1[2][5]=3;\n        //遍历二维数组(走个形式)\n        System.out.println(&quot;遍历二维数组Arr1&quot;);\n        for(int []row:Arr1)&#123;\n            for(int data:row)&#123;\n                System.out.printf(&quot;%d\\t&quot;,data);\n            &#125;\n            System.out.println();//每遍历一行换行\n        &#125;\n        //ok, 接下来我们将原始二维数组转换为稀疏数组，第一步是得到非零元素的个数 sum\n        int sum=0;\n        for(int i=0;i&lt;Arr1.length;i++)&#123;\n            for(int j=0;j&lt;Arr1[i].length;j++)&#123;\n                if(Arr1[i][j]!=0)&#123;\n                    sum++;\n                &#125;\n            &#125;\n        &#125;\n        //有了非零元素的个数 sum 后，就可以创建稀疏数组了 sparseArr [sum+1][3] 了\n        int sparseArr[][]=new int [sum+1][3];\n        //第一行是稀疏数组的整体结构\n        sparseArr[0][0]=10;\n        sparseArr[0][1]=10;\n        sparseArr[0][2]=sum;\n        //接下来将非零值存放到数组中\n        int count=0;\n        for(int i=0;i&lt;10;i++)&#123;\n            for(int j=0;j&lt;10;j++)&#123;\n                if(Arr1[i][j]!=0)&#123;\n                    count++;\n                    sparseArr[count][0]=i;\n                    sparseArr[count][1]=j;\n                    sparseArr[count][2]=Arr1[i][j];\n                &#125;\n            &#125;\n        &#125;\n        //这个时候稀疏数组已经创建完成了，我们来遍历一下稀疏数组\n        System.out.println(&quot;常用遍历&quot;);\n        for(int i=0;i&lt;sparseArr.length;i++)&#123;\n            System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);\n        &#125;\n        System.out.println(&quot;foreach遍历&quot;);\n        for(int[]row:sparseArr)&#123;\n            for(int data:row)&#123;\n                System.out.print(data+&quot;\\t&quot;);\n            &#125;\n        &#125;\n        //有了稀疏数组，这个时候我们将稀疏数组转换为二维数组\n        //先读取第一行创建原始的二维数组\n        int Arr2[][] = new int [sparseArr[0][0]][sparseArr[0][1]];\n        System.out.println(&quot;输出恢复后的二维数组&quot;);\n        //从稀疏数组的第二行开始将非零元素代入原始二维数组\n        for(int i=1;i&lt;sparseArr.length;i++)&#123;\n            Arr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];\n        &#125;\n        //遍历一遍转换后的二维数组\n        for(int[]row:Arr2)&#123;\n            for(int data:row)&#123;\n                System.out.print(data+&quot;\\t&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;队列\n队列是一个有序列表，可以用 数组（顺序存储）或者 链表（链式存储）来实现\n遵循 先入先出 的原则\n\n数组模拟队列\n将数据存入队列：addQueue, addQueue 处理有两个步骤：\n思路分析\n当 front&#x3D;&#x3D;rear（空的）将尾指针往后移：rear+1\n若 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素，否则无法存入数据。rear&#x3D;&#x3D;maxSize-1（队列满）\n\n\n\n\n\n这里拓展一下构造器和异常的知识\n构造器也叫做构造方法、构造函数，在项目中使用频繁，每次 new 一个对象的时候就会调用构造器，构造器的格式如下：\n修饰符（private、default、protected、public）\t类名\t（参数列表（可以没有参数））{（不能有 return）}\n注意事项\n\n构造器的名称和类名一致\n一个类中可以有多个构造器，构造器的参数列表必须不同（重载：可以简单理解为：同个方法名，不同的参数列表。）\n如果没有手动定义构造器，Java 会提供一个默认构造器以供使用，一旦我们定义了构造器，系统会把默认构造器收回\n构造器的作用：实例化对象，给对象赋初始值\n\n定义、使用、继承、重载\njava//一下是一个定义构造器的例子\npublic class Fu&#123;\n    public Fu()&#123;&#125;//无参数的公有构造方法\n    public Fu(int i)&#123;&#125;//有参数的公有构造方法\n&#125;\n//创建 Fu 的一个子类 Demo\npublic class Demo extends Fu&#123;\n    public Demo()&#123;&#125;//无参数的公有构造方法\n    public Demo(int i)&#123;&#125;//有参数的公有构造方法\n&#125;\n//构造器的使用\npublic static void main(String[] args)&#123;\n    //使用方法 1：new 一个对象\n    Demo d1 = new Demo();\n    Demo d2 = new Demo(int i);\n&#125;\n//使用方法 2：在构造方法中使用 this 和 super 关键字，必须在构造方法的第一条语句，且不能同时存在\npublic Demo()&#123;\n  this(2); //这里调用参数为 int 类型的本类的构造方法，即调用了 Demo(2)\n &#125;\npublic Demo()&#123;\n  super(1); //调用参数为 int 类型的父类的构造方法, 即调用了 Fu(1)\n &#125; \n//构造器继承\n//子类构造器会默认调用父类无参构造器，如果父类没有无参构造器，则必须在子类构造器的第一行通过 super 关键字指定调用父类的哪个构造器\n//父类构造器\npublic class Father&#123;\n    //自定义带参构造器\n    public Father(String str)&#123;\n        System.out.println(&quot;父类的带参构造方法，参数为：&quot;+str);\n    &#125; \n&#125;\n//子类构造器\npublic class Son extends Father&#123;\n    //无参构造器\n    public Son()&#123;\n        //由于 Father()没有无参构造器，所以必须在子类型构造器中通过 super(&quot;字符串&quot;)来调用，否则编译器会报错。\n        //如果没定义这句，系统会默认调用 super()\n        super(&quot;&quot;);\n    &#125;\n    //带参构造器\n    public Son(String str)&#123;\n        //由于 Father()没有无参构造器，所以必须在子类型构造器中通过 super(&quot;字符串&quot;)来调用，否则编译器会报错。\n        //如果没定义这句，系统会默认调用 super()\n        super(str);      \n    &#125;  \n&#125;\n代码实现数组模拟队列：\njavapackage com.data.arrayQueue;\nimport java.util.Scanner;\n//使用数组模拟队列：编写一个类\nclass ArrayQueue&#123;\n  private int maxSize;//表示数组的最大容量\n  private int front;//指向队列头的前一个位置\n  private int rear;//指向队列尾\n  private int[] arr;//该数组用于存放数据: 模拟队列\n\n  //创建队列的构造器\n  public ArrayQueue(int arrMaxSize)&#123;\n      maxSize = arrMaxSize;\n      arr = new int[maxSize];\n      //front 和 rear 开始都是-1\n      front = -1;//队列头的前一个位置\n      rear = -1;//队列尾的数据\n  &#125;\n  //判断队列是否满\n  public boolean isFull()&#123;\n      return rear==maxSize-1;\n      //队列满时，rear = maxSize-1\n  &#125;\n  //判断队列是否空\n  public boolean isEmpty()&#123;\n      return rear==front;\n      //队列空时，rear = front\n  &#125;\n  //添加数据到队列\n  public void addQueue(int n)&#123;\n      //先判断队列是否满\n      if(isFull())&#123;\n          System.out.println(&quot;队列满，不能加入数据&quot;);\n          return;\n      &#125;\n      rear++;//队列未满，执行 rear 后移\n      arr[rear]=n;\n  &#125;\n  //获取队列的数据(数据出队列)\n  public int getQueue()&#123;\n      if(isEmpty())&#123;\n          //抛出异常\n          throw new RuntimeException(&quot;队列空，不能取出数据&quot;);\n      &#125;\n      front++;\n      return arr[front];\n  &#125;\n  //显示队列所有数据\n  public void showQueue()&#123;\n      //遍历数组\n      if(isEmpty())&#123;\n          System.out.println(&quot;队列空，无法遍历&quot;);\n          return;\n      &#125;\n      for(int i=0;i&lt;arr.length;i++)&#123;\n          System.out.printf(&quot;arr[%d]=%d\\n&quot;,i,arr[i]);\n      &#125;\n  &#125;\n  //显示队列的头数据，注意不是取出数据\n  public int headQueue()&#123;\n      if(isEmpty())&#123;\n          throw new RuntimeException(&quot;队列空，无头数据&quot;);\n      &#125;\n      return arr[front+1];\n  &#125;\n&#125;\npublic class ArrQueue&#123;\n  public static void main(String[] args)&#123;\n      //测试一下\n      //创建一个新队列\n      ArrayQueue queue = new ArrayQueue(3);\n      char key = &#39; &#39;;//接收用户输入\n      Scanner scanner =new Scanner(System.in);\n      boolean loop = true;//默认死循环\n      //输出一个菜单\n      while(loop)&#123;\n          System.out.println(&quot;s(show):显示队列&quot;);\n          System.out.println(&quot;e(exit):退出程序&quot;);\n          System.out.println(&quot;a(add):添加数据到队列&quot;);\n          System.out.println(&quot;g(get):从队列取出数据&quot;);\n          System.out.println(&quot;h(head):查看队列头的数据&quot;);\n          key = scanner.next().charAt(0);\n          switch(key)&#123;\n              case &#39;s&#39;:\n                  queue.showQueue();\n                  break;\n              case &#39;a&#39;:\n                  System.out.println(&quot;输出一个数&quot;);\n                  int value = scanner.nextInt();\n                  queue.addQueue(value);\n                  break;\n              case &#39;g&#39;:\n                  System.out.println(&quot;取出队列数据&quot;);\n                  try&#123;\n                      //因为从队列中取出数据会先判断队列是否为空，空队列时会抛出异常，这时候使用 java 的异常处理机制 try-catch 来处理\n\n                      int res = queue.getQueue();\n                      //如果 getQueue 抛出异常就会被下面的 catch 抓住\n                      System.out.printf(&quot;取出的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      //如果抛出异常，就输出 e 中的异常\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;h&#39;:\n                  System.out.println(&quot;查看队列头数据&quot;);\n                  try&#123;\n                      int res = queue.headQueue();\n                      System.out.printf(&quot;队列头的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;e&#39;:\n                  scanner.close();\n                  loop=false;\n                  break;\n              default:\n                  break;\n          &#125;\n          System.out.println(&quot;程序退出&quot;);\n      &#125;\n  &#125;\n&#125;\n以上是数组模拟队列的代码实现，但是这段代码是有问题的，数组使用一次就不能用了（没有释放被取出的数据的空间），没有达到复用的效果，为了改进，将这个数组使用算法改进成一个环形的数组（取模%）\n数组模拟环形队列使用数组模拟环形队列的思路分析：\n\n队列的大小为 k 的话，就创建 k+1 大小的环形队列（空出一个空间来）maxSize 为有效数据个数+1\nfront 变量的含义做一个调整：front 指向队列的第一个元素（而不是原来指向头元素的前一个位置）即 arr [front] 即队列的第一个元素，front 的初始值默认为 0\nrear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置，希望空出一个空间作一个“约定”，rear 的初始值为 0\n当队列满时，条件是 (rear+1)%maxSize &#x3D;&#x3D; front\n队列为空的条件仍然是 rear&#x3D;&#x3D;front\n队列中有效数据的个数：**(rear+maxSize-front)%maxSize**\n\n下列图片判断环形队列是否为满（重点）\n在 front &#x3D; 0，rear &#x3D; 3，maxSize &#x3D; 8 的情况下，（rear + 1） % maxSize &#x3D; 4，而 4 !&#x3D; 0，所以数组没有满，依然可以存储数据。在 front &#x3D; 0，rear &#x3D; 7，maxSize &#x3D; 8 的情况下，（rear + 1） % maxSize &#x3D; 0，而 0 &#x3D; 0，数组已经存满\n\n\n代码实现环形队列\njavaclass ArrayQueue&#123;\n  private int maxSize;//表示数组的最大容量\n  private int front;//指向队列头, 初始值为 0\n  private int rear;//指向队列尾的后一个元素，初始值为 0\n  private int[] arr;//该数组用于存放数据: 模拟队列\n  //构造器\n  public ArrayQueue(int arrMaxSize)&#123;\n      maxSize = arrMaxSize;\n      arr = new int[maxSize];\n      fornt = 0;\n      rear = 0;\n      //两个值默认就是 0，可以不赋值\n  &#125;\n    public boolean isFull()&#123;\n        return (rear+1) % maxSize == front;\n    &#125;\n    public boolean isEmpty()&#123;\n        return front == rear;\n    &#125;\n    public void addQueue(int n)&#123;\n        if(isEmpty())&#123;\n            System.out.println(&quot;队列满&quot;);\n            return;\n        &#125;\n        //先将数据后移，在存入数据，必须将 rear 取模\n        arr[rear] = n;\n        rear = (rear+1) % maxSize;\n    &#125;\n    public int getQueue()&#123;\n        if(isEmpty())&#123;\n            throw new RuntimeException(&quot;队列空&quot;);\n        &#125;\n        //分析出 front 是指向队列的第一个元素\n        //先把 front 保存到临时变量，再将 front 后移(考虑取模)\n        int value = arr[front];\n        front = (front+1) % maxSize;\n        return value;\n    &#125;\n    public void showQueue()&#123;\n        if(isEmpty())&#123;\n            System.out.println(&quot;队列空，没有数据~&quot;);\n            return;\n        &#125;\n        //从 front 开始遍历, 遍历(rear+maxSize-front)%maxSize 个元素\n        for(int i = front;i&lt;front+size();i++)&#123;\n            System.out.printf(&quot;arr[%d]=%d\\n&quot;,i % maxSize,arr[i%maxSize]);\n        &#125;\n    &#125;\n    //需要一个方法求出当前队列有效数据的个数\n    public int size()&#123;\n        return (rear+maxSize-front) % maxSize;\n    &#125;\n    public int headQueue()&#123;\n        if(isEmpty())&#123;\n            throw new RuntimeException(&quot;队列空&quot;);\n        &#125;\n        return arr[front];\n    &#125;\n&#125;\npublic class CircleArrayQueue&#123;\n    public static void main(String[] args)&#123;\n      //测试一下\n      //创建一个环形队列\n      ArrayQueue queue = new ArrayQueue(4);\n      char key = &#39; &#39;;//接收用户输入\n      Scanner scanner =new Scanner(System.in);\n      boolean loop = true;//默认死循环\n      //输出一个菜单\n      while(loop)&#123;\n          System.out.println(&quot;s(show):显示队列&quot;);\n          System.out.println(&quot;e(exit):退出程序&quot;);\n          System.out.println(&quot;a(add):添加数据到队列&quot;);\n          System.out.println(&quot;g(get):从队列取出数据&quot;);\n          System.out.println(&quot;h(head):查看队列头的数据&quot;);\n          key = scanner.next().charAt(0);\n          switch(key)&#123;\n              case &#39;s&#39;:\n                  queue.showQueue();\n                  break;\n              case &#39;a&#39;:\n                  System.out.println(&quot;输出一个数&quot;);\n                  int value = scanner.nextInt();\n                  queue.addQueue(value);\n                  break;\n              case &#39;g&#39;:\n                  System.out.println(&quot;取出队列数据&quot;);\n                  try&#123;\n                      //因为从队列中取出数据会先判断队列是否为空，空队列时会抛出异常，这时候使用 java 的异常处理机制 try-catch 来处理\n\n                      int res = queue.getQueue();\n                      //如果 getQueue 抛出异常就会被下面的 catch 抓住\n                      System.out.printf(&quot;取出的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      //如果抛出异常，就输出 e 中的异常\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;h&#39;:\n                  System.out.println(&quot;查看队列头数据&quot;);\n                  try&#123;\n                      int res = queue.headQueue();\n                      System.out.printf(&quot;队列头的数据是%d\\n&quot;,res);\n                  &#125;catch(Exception e)&#123;\n                      System.out.println(e.getMessage());\n                  &#125;\n                  break;\n              case&#39;e&#39;:\n                  scanner.close();\n                  loop=false;\n                  break;\n              default:\n                  break;\n          &#125;\n          System.out.println(&quot;程序退出&quot;);\n      &#125;\n  &#125;\n&#125;链表链表是有序的列表，内存存储如下\n\n\n链表以节点的方式存储，是链式存储\n每个节点包括 data 域，next 域：指向下一个节点\n每个节点不一定是连续存放\n链表分为带头节点的链表和没有头结点的链表，根据实际需求来确定\n\n逻辑结构如下：\n逻辑结构好似的连续的，但实际的内存存储一般是不连续的\n使用带 head 头的单向链表实现人物排行榜管理\n要求：\n\n完成对人物的增删改查的操作\n第一种方法在添加人物时，直接添加到链表尾部\n第二种方式在添加任务时，考虑人物排名\n\n代码的具体实现\njavapackage com.data.LinkList;\n\n//先定义一个 Node，每个 Node 对象是一个节点\nclass Node&#123;\n  public int no;\n  public String name;\n  public String nickname;\n  public Node next;//指向下一个节点的 next 域\n  //创建构造器\n  public Node(int No,String Name,String Nickname)&#123;\n      this.no=No;\n      this.name=Name;\n      this.nickname=Nickname;\n  &#125;\n  //显示方法：重新 toString\n  public String toString() &#123;\n        return &quot;Node [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname;\n    &#125;\n&#125;\n//定义一个 SingleLinkList 管理人物\nclass SingleLinkListDemo&#123;\n  //初始化一个头节点，头节点不存放具体数据\n  private Node head = new Node(0,&quot;&quot;,&quot;&quot;);\n  //添加节点\n  //不考虑编号顺序时，找到当前链表的最后节点，next 域直接指向新的节点即可\n  public void add(Node node)&#123;\n      //head 节点不能动，所以需要定义一个辅助变量\n      Node temp = head;\n      //遍历\n      while(true)&#123;\n          //当找到链表的尾部\n          if(temp.next == null)&#123;\n              break;\n          &#125;\n          //如果没有找到最后\n          temp = temp.next;\n          //当推出 while 循环时，temp 一定是指向链表的最后\n      &#125;\n      temp.next = node;\n  &#125;\n  //显示链表遍历链表\n  public void list()&#123;\n      //判断链表是否为空\n      if(head.next == null)&#123;\n          System.out.println(&quot;链表为空&quot;);\n      &#125;\n      //链表不为空时，头结点不能动，需要一个辅助变量遍历\n      Node temp = head.next;\n      while(true)&#123;\n          //判断是否到链表最后\n         if(temp == null)&#123;\n             break;\n         &#125;\n          //输出节点信息, 再将 temp 后移\n          System.out.println(temp);\n          temp = temp.next;\n      &#125;\n  &#125;\n    public void addByOrder(Node node)&#123;\n        Node temp = head;\n        boolean flag = false;\n        while(true)&#123; \n            if(temp.next = null)&#123;\n                break;//temp 在链表尾部\n            &#125;\n            if(temp.next.no&gt;node.no)&#123;//在 temp 后面添加\n                break;\n            &#125;else if(temp.next.no = node.no)&#123;//添加的编号已经存在了\n                flag == true;//编号存在\n                break;\n            &#125;\n            temp = temp.next;//后移，遍历当前链表\n        &#125;\n        //退出循环后，判断 flag 的值\n        if(flag== true)&#123;//flag 为真，不能添加，说明编号存在\n            System.out.printf(&quot;编号%d已经存在\\n&quot;,node.no);\n        &#125;else&#123;\n            //插入到链表中了\n            node.next = temp.next;\n            temp.next = node;\n        &#125;\n    &#125;\n&#125;\npublic class SingleLinkList &#123;\n    public static void main(String[] args)&#123;\n        //测试一下\n        //先创建节点\n        Node h1 = new Node(1,&quot;穆佳一&quot;,&quot;老大&quot;);\n        Node h2 = new Node(2,&quot;王兆淼&quot;,&quot;老二&quot;);\n        Node h3 = new Node(3,&quot;小王兆淼&quot;,&quot;老三&quot;);\n        Node h4 = new Node(4,&quot;小小王兆淼&quot;,&quot;老四&quot;);\n        //加入之前，创建一个链表\n        SingleLinkListDemo singleLinkList = new SingleLinkListDemo();\n        //加入\n        singleLinkList.add(h1);\n        singleLinkList.add(h2);\n        singleLinkList.add(h3);\n        singleLinkList.add(h4);\n        //显示一下\n        singleLinkList.list();\n        \n    &#125;\n\n&#125;\n下面代码块介绍节点修改的代码\n修改节点时，编号不变，节点的信息改变\njava//根据编号修改\npublic void update(Node newnode) &#123;\n    if(head.next==null)&#123;\n        System.out.println(&quot;链表为空&quot;);\n        return;\n    &#125;\n    //找到要修改的节点\n    Node temp = head.next;\n    boolean flag = false;//表示是否找到该节点\n    while(true)&#123;\n        if(temp == null)&#123;\n            //到了链表最后了\n            break;\n        &#125;\n        if(temp.no == newnode.no)&#123;\n            flag = true;\n            break;\n        &#125;\n        temp = temp.next;\n    &#125;\n    //根据falg判断是否找到节点\n    if(flag)&#123;\n        temp.name = newnode.name;\n        temp.nickname = newnode.nickname;\n    &#125;else&#123;\n        //没有找到\n        System.out.println(&quot;没有找到该编号对应的节点&quot;);\n    &#125;\n&#125;","slug":"Java数据结构和算法","date":"2024-01-24T12:30:11.000Z","categories_index":"编程","tags_index":"Java","author_index":"Ed-RYan"},{"id":"fa8c242a44c2320cdf0d2adc7864bdb1","title":"蓝桥杯知识点汇总","content":"蓝桥杯知识点汇总基础算法\n\n\n枚举\n模拟\n贪心\n递归\n分治\n\n\n\n构造\n前缀和差分\n\n\n\n\n\n搜索和排序\n\n\n子集生成\n线性搜索\n二分法\n三分法\nBFS\n\n\n\n双向广搜\n广搜优化\nA 算法\nDFS\n回溯剪枝\n\n\n深搜优化\n记忆化搜索\nIDA 算法\n位运算\n按位压缩存储状态\n\n\n极大极小问题\nM 进制存储状态\n舞蹈链\n选择排序\n冒泡排序\n\n\n插入排序\n归并排序\n快速排序\n堆排序\n计数排序\n\n\n基数排序\n桶排序\n\n\n\n\n\n动态规划\n\n\n编辑距离\n最长不重复子串\n整数背包\n矩阵连乘\n最长公共子序列\n\n\n\n最长公共递增子序列\n最长公共子串\n最长上升子序列\n最长回文子序列\n最长回文子串\n\n\n回文分割\n最大子段和\n最大正方形子矩阵\n最长链对\n最大递增子序列和\n\n\n滚动数组\n\n\n\n\n\n\n数位 dp\n概率 dp\n树形 dp\n区间 dp\n状压 dp\n\n\n插头 dp\n斜率优化\n平行四边形优化\n单调队列优化\n数据结构优化\n\n\n数学\n\n\nGCD&amp;LCM\n素数判断\n素数生成\n分解质因数\n欧拉定理\n\n\n\n费马小定理\n扩展欧几里得\n逆元\n随机素数测试和大数分解\n高斯消元\n\n\n佩尔方程\n整数拆分\n大步小步算法\n中国剩余定理\n原根\n\n\n快速数论变换\n线性丢番图方程\n模运算\n卢卡斯定理\n杜教筛\n\n\n威尔逊定理\n米勒罗宾随机素数测试\n完全数\n连分数\n\n\n\n组合数学\n\n\n容斥原理\n鸽巢定理\n乘法原理\n斯特林数\n卡特兰数\n\n\n\n斐波那契数\n幻方\n莫比乌斯反演\n母函数\n调和级数\n\n\n图论\n\n\n邻接矩阵、关联矩阵\n邻接表\n链式前向星\n有向无环图\n哈密顿图\n\n\n\n欧拉图\n判圈\n割点\n割边\n桥\n\n\n双连通分量\n强连通分量\n有向图的强连通分量\n拓扑排序\n二分图判定\n\n\n2-SAT\n最短路径\n连通分量\nPrim\nKruskal\n\n\n次小生成树\n曼哈顿最小生成树\n堆优化\nBellman\n弗洛伊德算法\n\n\n差分约束\nSPFA\n最小费用最大流\n二分图匹配\n欧拉路\n\n\n数据结构\n\n\n数组\n链表\n栈\n队列\n先队列\n\n\n\n双端队列\n块状链表\n堆\n哈希\nLCA\n\n\n跳跃表\n并查集\n字典树\n线段树\n树状数组\n\n\n莫队算法\n平衡二叉树\n二叉搜索树\nTreap 树\n二叉树\n\n\n笛卡尔树\n划分树\n表达式树\n替罪羊树\n伸展树\n\n\n动态树\n左偏堆\n可并堆\n主席树\n树链剖分\n\n\nKD 树\n树套树\nFHQ_Treap\n\n\n\n\n几何\n\n\n点和向量\n点积、叉积\n点和线的关系\n多边形\n三角形的内心、外心、重心、垂心\n\n\n\n费马点\n面积、周长、体积\n判点在多边形多面体内外\n三角剖分\n梯形剖分\n\n\n多边形重心\n多边形切割\n多面体体积\n坐标旋转\n凸包\n\n\n最近点对\n旋转卡壳\n半平面交\n最小圆覆盖\n\n\n\n三维点和向量\n三维点积&amp;叉积\n最小球覆盖\n三维凸包\n\n\n\n","slug":"LqKnowledgePoint","date":"2024-01-23T02:13:50.000Z","categories_index":"","tags_index":"算法","author_index":"Ed-RYan"},{"id":"50dae02cf68f09e79955ea48c8fd607c","title":"瞎学的java基础语法","content":"ε &#x3D;(´ο｀*)))唉，上次用 Java 还是在上次，感觉语法什么的已经忘得干干净净了，先来总结一些我易混的知识点啥的恢复一下记忆\nJava标识符定义：包（package），类（Class），方法（Method），变量（Variable）起名字的符号\n组成规则：由字母、数字、下划线“_”、美元符号$或者￥组成，首字符不能是数字，不能是 Java 中的关键字，大小写敏感，无长度限制，不能包含空格。\nJava 注解定义：用于解释说明程序的文字\n分类：单行注释“&#x2F;&#x2F;”, 快捷键：Ctrl+&#x2F;\n​\t\t\t多行注释”&#x2F; * 注释文字 * &#x2F;“”，快捷键：Ctrl+Shift+&#x2F;\nJava 访问修饰符定义： 使用访问修饰符可以保护对类、变量、方法、构造方法的访问，Java 中有四种不同的访问权限\n分类： private：在同一类（Class）内可见，不能修饰类（外部类）\n​\t\t\tdefault：（缺省，什么也不写，不使用关键字）在同一包（package）内可见，不适用任何修饰符，也叫包访问权限。\n​\t\t\tprotected：对同一包内的类和所有子类可见。不能修饰类（外部类）\n​\t\t\tpublic：对所有类可见\n拓展：一个 Java 源程序中可以有多个 Class 类，但只能有一个类是 public 的。\n​\t\t\tjava 程序是从一个 public 程序中的 main 函数开始执行的，就像 C++程序从 main（）开始执行一样。\n​\t\t\t只能有一个 public 是为了给 类装载器 提供方便，public 只能定义在以他的类名为文件名的文件中（严格区分大小写）\nJava 分隔符、转义符分隔符定义：空格、逗号、分号以及行结束符，规定任意两个相邻标识符、数字、保留字、语句之间必须存在至少一个分隔符，以保证程序编译时能正常识别。\n分类：\n\n​\t\t\t分号“；”\t用于终止一个语句\n​\t\t\t冒号“：”\t\n​\t\t\t花括号、大括号“{}”\t用于包括自动初始化数组的值，也用于定义程序块、类、方法以及局部范围。\n​\t\t\t方括号、中括号“[]”\t用于声明数组类型，也用于撤销对数组值的引用。\n​\t\t\t逗号“，”\t在变量声明中，区分变量说明的各个变量。在 for 控制语句中将圆括号内的语句连接起来\n​\t\t\t圆点“.”\t将软件包的名字和他的子包或类相分隔，也用来将引用变量与变量或者方法分隔\n​\t\t\t圆括号“（）”\t定义和调用方法时容纳参数表，在控制语句或者强制类型转换表达式中表示执行或者计算的优先权\n​\t\t\t尖括号“&lt;&gt;”\t将参数传递给参数化类型\n\n转义符定义：特殊的字符常量，以反斜线“\\”开头，后跟一个或者几个字符，通常具有特定的含义，不同于字符原有的意义。\n常用转义字符\n\n\n\n转义字符\n意义\nASCII 码制\n\n\n\n\\n\n换行符（LF）\n10\n\n\n\\r\n回车（CR）\n13\n\n\n\\y\n水平制表（HT）（一个 Tab）\n9\n\n\n\\v\n垂直制表（VT）\n11\n\n\n\\\\\n代表一个反斜线字符‘\\’\n92\n\n\n\\‘\n代表一个单引号字符\n39\n\n\n\\“\n代表一个双引号字符\n34\n\n\n\\0\n空字符（NULL）\n0\n\n\nJava 数据类型定义：Java 是强制类语言，对于每一种数据定义明确了具体的数据类型，内存中分配不同大小的内存空间\n基本数据类型数值型\n整数类型\t\n\n\n\n数据类型\n字节\n位数\n\n\n\nbyte\n1\n8\n\n\nshort\n2\n16\n\n\nint\n4\n32\n\n\nlong\n8\n64\n\n\n定义 long 类型时要在后面加后缀 L 或者 l\n浮点类型\n\n\n\n数据类型\n字节\n位数\n\n\n\nfloat\n4\n32\n\n\ndouble\n8\n64\n\n\n定义浮点类型时候后缀没有 F 或者 f 时候默认是 double 类型，float 类型赋值时需要添加后缀 F 或者 f\n字符型\nchar，采用 Unicode 编码，两字节表示一个字符，\n布尔型\nblloean，1 字节表示一个字符\n引用数据类型类(class)接口(interface)数组([])\n简单数据转换Java 中整形，实型（浮点型），字符型都被称为简单数据类型，这些类型由低级到高级分别为：\n（byte，short，char） - int - long - float - double\n简单数据类型之间的转换又分为：\n\n低级到高级的自动类型转换\n\n高级到低级的强制类型转换（可能导致溢出或者精度下降）\n\n包装类过渡类型能够转换\n\n\njava//自动类型转换\n  byte b;\n  int i=b;\n  long l=b;\n  float f=b;\n  double d=b;\njava//低级类型为 char 型，向高级类型（整形）转换，会转换为对应的 ASCII 码\nchar c=&#39;c&#39;;\nint i=c;\n//System.out.println(&quot;output:&quot; i);\n//输出：output: 99;javapublic static void main(String[] args) &#123;\n    //1.多个类型数据混合运数时，系统会按最大的类型进行转换\n    int a = 10;\n    //float a1 = a + 1.1; //错误  结果类型一个是 double\n    float a2 = a + 1.1F;  //结果类型一个是 float\n    double a3 = a + 1.1;  //结果类型一个是 double\n    //2.容量大的赋值给容量小的肯定会报错\n    //int b = 1.1; //错误 原因：double -&gt; int\n    //3.(byte，short) 和 char 之间不会相互自动转换\n    byte b1 = 10; //正确\n    int b2 = 1;\n    //byte b3 = b2; //错误 原因：变量赋值，判断该类型\n    //char c1 = b1; //错误 原因：byte 不能自动转换为 char\n    //4.byte，short，char 该三个数据类型计算，计算时首先转换为 int 类型\n    byte c1 = 1;\n    short c2 = 2;\n    //short c3 = c1 + c2; //错误 原因：计算时首先转换为 int 类型\n    int c3 = c1 + c2; //正确\n\n&#125;\nfloat 型转换为 double 型\njavafloat f1=100.00f;\nFloat F1=new Float(f1);\n//F1.doubleValue()为 Float 类的返回 double 值型的方法\ndouble d1=F1.doubleValue();\ndouble 型转换为 int 型：\njavadouble d1=100.00;\nDouble D1=new Double(d1);\nint i1=D1.intValue();\n//直接把 double 型的小数位去除字符串类的转换这里不在叙述，之后会单独开一节字符类型的学习\nJava 变量定义：在程序执行过程中，某个范围内可以发生改变 的量，从本质上讲变量其实是内存中的一小块区域。\n按被声明的位置划分成员变量：方法外部，类的内部定义的变量\n\n类变量（静态变量） 独立于方法之外的变量，用 static 修饰\n静态变量以 static 关键字声明，必须在方法构造方法和语句块之外\n静态变量存储在静态存储区，经常被声明为常量，很少单独使用 static 声明。\n静态变量第一次访问时被创建，程序结束时被销毁。\n\n\n实例变量（非静态变量） 定义在类中但在任何方法之外，没有 static 修饰\n实例变量声明在一个类当中，但是在方法、构造方法和语句块之外\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁\n\n\n局部变量\n类的方法中的变量\n局部变量声明在方法、构造方法或者语句块中\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁\n访问修饰符不能用于局部变量\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用\n\n\n\n按所属的数据类型划分基本数据类型变量\n\n基本数据类型\nbyte，short，int，float，double，char，boolean\n\n\n变量定义\n数据类型 变量名 &#x3D; 初始化值\n\n\n注意\n整型默认是 int 类型，定义 long 类型时要在数据后面加 L 或者 l，浮点型默认是 double 型，定义 float 型时需要在数据后面加 F 或者 f\n\n\n\n引用数据类型（类，接口，数组）\n\n定义格式\n数据类型 变量名 &#x3D; 初始化值\n\n\n\njavapublic class Variable&#123;\n    // 类变量\n    static int globalNum=10;    \n     // 实例变量\n    String str=&quot;hello world&quot;;  \n    public void method()&#123;\n        // 局部变量\n        int i =10;  \n    &#125;\n&#125;\nJava 常量定义：Java 中用关键字 final 定义一个常量，，常量被初始化后其值不可以发生改变。常量可以在程序执行的过程中使用一个符号来代替常量值使用，因此在使用前必须定义。\n分类：\n\n字符串类常量：用双引号括起来的内容\n整数常量：所有整数\n小数常量：所有小数\n字符常量：用单引号括起来的内容\n布尔常量：只有 true 和 false\n空常量：null\n\njavafinal int CONUT = 1;\nfinal float PI = 3.1415f;运算符定义：运算符指明对操作数的运算方式\n\n\n算数运算符\n\n\n\n\n运算符\n运算\n\n\n\n+\n加\n\n\n-\n减\n\n\n*\n乘\n\n\n&#x2F;\n除\n\n\n%\n取模\n\n\n++\n自增\n\n\n–\n自减\n\n\n+\n字符串相加\n\n\n注意事项\n\n除号&#x2F;左右两端的类型需要一致\n取模%最后的符号和被模数相同\n前++，先+1，后运算，后++，先运算，后+1\n+：当 String 字符串与其他数据类型只能做连接运算，并且结果为 String 型\n\n\n\n\n关系运算符\n\n​\t\n\n\n\n运算符\n运算\n\n\n\n&#x3D;&#x3D;\n相等于\n\n\n！&#x3D;\n不等于\n\n\n&lt;\n小于\n\n\n&gt;\n大于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;&#x3D;\n大于等于\n\n\ninstanceof\n检查是否为类的对象\n\n\n注意事项\n\nInstanceof 运算符\n语法：对象名 instanceof 类或接口\n\n\n\n\n\n\n赋值运算符\n&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;\n\n逻辑运算符\n\n\n\n逻辑运算符\n功能\n\n\n\n||（短路或）\n都为 false 则为 false，有一个为 true 便不再判断了\n\n\n|（逻辑或）\n都为 false 则为 false，所有条件都判断\n\n\n&amp;&amp;（短路与）\n都为 true 则为 true，有一个为 false 便不在判断了\n\n\n&amp;（逻辑与）\n都为 true 则为 true，所有条件都判断\n\n\n！（非）\n变成相反\n\n\n^（异或）\n相同为 false，不同为 true\n\n\n\n位运算符\n\n三目运算符\n（条件表达式 A）？表达式 1：表达式 2；\n若条件表达式 A 为 true，则运算结果为表达式 1；否则为表达式 2\n\n\nJava 流程控制——顺序控制结构顺序控制结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\nJava流程控制——选择控制结构定义：条件语句根据不同条件执行不同语句，包括if语句和switch多分支语句\nif分支结构&#x2F;if-else分支结构&#x2F;if-else if-else分支结构\nswitch分支结构\njavaswitch(/*表达式*/)&#123;\n    case 2:\n        //执行的代码\n        break;\n    case 1:\n        //执行的代码\n        default;\n            \n&#125;","slug":"javaGrammar","date":"2024-01-21T15:53:45.000Z","categories_index":"编程","tags_index":"java","author_index":"Ed-RYan"},{"id":"1451337e2cd8330994910442b8a41dbc","title":"Java学习笔记","content":"JAVA程序使用记事本编写代码\npublic 访问修饰符用于控制程序的其他部分对这段代码的访问级别\nclass是类，java是面向对象的语言，所有对象必须位于类里面\n一个源文件只能声明一个public的类，其他类个数不限，且源文件名必须和public类名相同，且以.java为后缀。\nmain方法是程序执行的入口，有固定的书写格式\njavapublic static void main(String[] args)&#123;\n    &#125;花括号的使用规范\nJava中各个语句依然必须以分号结束。回车不是结束的标志，所以一个语句可以跨多行\n注意：编程时一定注意缩进规范，写括号，引号时一定成对编写，然后再往里面插入内容。\n常用DOS命令1,cd\t目标路径\t\t进入一个子目录\n2，cd..\t\t\t进入父目录\n3，dir\t\t\t查看本目录下的子文件列表\n4，cls\t\t\t清除屏幕\n5，上下键\t\t\t查找敲过的命令\n6，Tab键\t\t\t自动补全命令\n不需要花费时间学习太多DOS命令\n因为大多数编程过程一般都是在Idea，Eplise等编辑器中进行编辑的\n变量和数据类型和运算符预备知识：\n二进制\t\t0\t\t1\n万物皆有规律，规律能量化，量化能数字化，数字化能计算机化\n二进制由莱布尼茨于1679年发明\n二进制可以对应两种状态，广泛应用于电子科学，比如可以对应电子器件开关状态，对应信号电压状态，对应电磁存储等等\n进制转换：十进制和二进制的相互转换\n满二进一\n要求掌握一些简单算法，权相加法，逆序排列法\n注释\n单行注释&#x2F;&#x2F;开头\n多行注释以\t\t&#x2F;*\t\t开头，以\t\t*&#x2F;结尾，\n文档注释\t\t&#x2F;**\t\t\t\t*&#x2F;\n注意多行注释不可以嵌套使用\n注释在编译过程中被忽略掉\n标识符\n就是起名的规则\n1，必须以字母，下划线，美元符号$开头，切记不能用数字开头\n2，标识符的其他部分还可以是数字\n3，Java标识符大小写敏感，长度无限制\n4，标识符不能是关键字\n标识符使用规范：\n表示类名的标识符：首字母大写\n表示方法和变量：第一个单词小写，第二个单词起首字母大写，称之为驼峰原则\nJava通常采用Unicode国际字符集，而不是ASCII字符集\n2个字节表示一个符号。\nACSII字符集一个字节一个符号，即2的八次方&#x3D;256个字符\nUnicode字符集2个字节一个符号，即2的十六次方&#x3D;65536个字符\n变量\n变量对应一个可操作的存储空间\n空间位置是确定的，但是里面放置什么不确定\n可通过变量名来访问对应的存储空间，从而操纵存储空间存储的值\n变量的声明：\njavatype varName [=value][,varName[=value]......];[\t]表示可有可无\nint 4个字节\ndouble 8个字节\nlong 8个字节\n变量的作用域\n\n局部变量：local variable，定义在方法&#x2F;语句块内部，\n\n成员变量\n\n静态变量\n\n\n常量\n声明格式：\njavafinal 常量类型 常量名 [=value];基本数据类型primitive date type\n数据类型分为基本数据类型和引用数据类型（引用数据类型统一大小为4字节，32位）\n基本数据类型分为数值型，字符型，和布尔型\n\n数值型又分为整数类型（byte[1],short[2],int[4],long[8]），浮点类型（float[4]，double[8]），\n字符型（char）\n布尔型（boolean）\n\n整型常量的表示形式\n\n十进制：33，44，55\n八进制：0开头\n十六进制：0x或者0X开头\n二进制：要求以0b或者0B开头\n\n定义long时应该在后面加L或者l；\n浮点型：\nfloat\t\t4字节\t\t\ndouble\t\t8字节\n浮点型是不精确的，有误差的，所以不要随便对于浮点数进行比较\n后缀没有f或者F的浮点类型默认是double类型，float类型赋值时需要添加后缀F或者f。\n字符型占两个字节，\nchar类型用于在Unicode编码中的字符，占2个字节，\nASCII码中字符型占1字节，256个字符；\n定义字符串(字符串不是基本数据类型，而是类)\njavaString str=&quot;\t\t&quot;转义字符：\n\\\n布尔类型boolean\n只有两个值true，false\n占用1个或者4个字节，不可以用0或非零的数来代替，\n运算符\n1，算数运算符\n二元运算符（+,-,*,&#x2F;,%）\n一元运算符（++，–）\n2，赋值运算符（&#x3D;）\n3，扩展运算符（+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;）\n4，关系运算符（&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;，instance of）\n5，逻辑运算符（&amp;&amp;，||，！，^）\n6，位运算符（&amp;，|，^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;）\n7,条件运算符（？：）\n8，字符串连接符（+）；\n算数运算符\nint和long运算，结果转为long，\n若没有long，则结果全为int\n两个操作数有一个为double，则结果为double\n两个操作数都是float，结果才为float\n取模运算的操作数一般为浮点数，但是一般使用整数。结果是余数，余数的符号和左边的操作数相同\n控制语句（三种基本结构）\n顺序结构\n条件判断结构\n循环结构\n条件判断（三种结构）\nif单分支\nif-else双分支结构\nif-else if-else多分支结构\nswitch语句多分支结构\njavaswitch(variable)\n&#123;\n    case 1:语句;break\n    case 2;语句;break\n    case 4.语句;default;\n&#125;循环结构\nJava程序的运行机制高级语言一般分为两种：编译型语言和解释型语言\nJava是两者的结合\n文本编译器编写源程序，后缀为.java，\n再利用编译器编译成字节码文件，后缀为.class,\n最后利用虚拟机（解释器，java）解释执行。\nJVM,JRE,JDK（是相互包含的关系)JVM，就是一个虚拟机，用于执行bytecode字节码，可以边解释便运行java的跨平台就是通过java虚拟机来运行的\n对于程序来说，编写的代码是一样的，对于用户来说，不同的系统只需要按照对应的虚拟机，来解释字节码文件。\n不同操作系统利用不同的虚拟机，来屏蔽底层运行平台的差异\nJRE，包含Java虚拟机，库函数，运行Java应用程序必须的文件JDK，包含JRE，以及增加编译器和调试器等用于程序开发的文件作为一个开发者，需要安装JDK\nJava发展简史1991开始研发，SUN公司，设计小型计算机语言\nJAVA核心优势：跨平台\n赶上互联网爆发的时代优势形成了强大的生态体系\nJava在未来几十年的时间会成为编程的主流语言\n各版本JAVASE（JAVA Standard Edition）标准版：定位在个人计算机上的应用\nJAVAEE（JAVA Enterprise Edition）企业版：定位在服务器端上的开发\nJAVAME（JAVA Micro Edition）微型版：定位在消费型电子产品上\nJava的特性和优势1，跨平台&#x2F;可移植性\njava的int永远是32位，不像c++，有时16有时32，跨平台实现不了\n2，安全\n3，面向对象\n4，简单性\n去除了头文件，指针运算，结构等等\n5，高性能\n6，分布式\n处理TCP&#x2F;IP协议\n7，多线程\n服务器端处理\nJAVA开发环境的搭建1，打开官网，安装JDK\n2，配置环境变量Path\nPath告诉计算机要运行一个程序而没有告诉其所在的完整路径时，除了在当前目录下寻找此程序外，还应该到哪些目录去寻找\n多种计算机语言介绍C语言1972，贝尔实验室，现代语言的鼻祖，\n目前在底层编程，嵌入式开发，病毒开发，系统程序，操作系统等\n学好C对学习编程非常有帮助\nC++混合式语言，既有面向过程，又有面向对象\n在科学计算，操作系统，网络通讯等方面\nJava1995，美国SUN公司，是目前业界最广泛使用人数最多的语言，称为计算机语言界的英语\n广泛应用于企业级软件开发，安卓移动开发，大数据云计算等领域，\nJavascript脚本语言，广泛应用于Web开发\nH5的开发核心是Javascript\nPython1989年，早于Java\n之前广泛应用于科研领域，WEB编程等等，但是目前在人工智能方面具有巨大潜力\nPHP一般用于WEB开发\n大量中小型网站使用PHP开发，\nObject-C和Swift语言苹果开发\nC#（C-sharp）微软公司，面向对象，运行于.NET框架平台之上的高级程序设计语言\n基于Windows操作系统应用开发这一块取代了C++，微软\nKotlin语言（考特林）目前已经正式成为安卓官方支持的语言，且可以兼容Java\nGo语言谷歌官方开发的语言\n易语言以中文作为程序代码编程语言，目前主要用来开发脚本，外挂等程序\nFortran语言IBM公司，1954\n复杂科学计算，工程领域\nBasic语言易学，功能不够强大，已经退出历史舞台\nPascal语言COBOL语言计算机语言发展史及未来发展方向工业革命——————解放体力\n信息革命——————解放脑力\n计算机已经成为了人类大脑的延伸计算机随处可见，手机，玩具，微波炉，洗衣机，汽车等，都有计算机的出现\n算法是计算机的灵魂，编程语言是塑造计算机灵魂的工具计算机编程语言经历了从低级到高级的发展，发展核心思想是“让人更容易编程”\n3个阶段\n1，机器语言（相当于人类的原始社会）\n通常是纯数字，0和1\n2，汇编语言（相当于人类的工业阶段）\n使用常见的汇编语言助记符\n在某些工业电子编程领域，软件的加密解密，计算机病毒分析等仍在使用\n3，高级语言（相当于人类的工业社会）\n程序开始非常易懂\n面向对象类和对象，内存底层，面向对象的三大特征，特殊类\n一，熟悉面向对象1，表格结构和类结构\n\n\n类（表结构）\nID\nName\nMoney\nDate\n\n\n\n对象\n0001\n张三\n1000\n9&#x2F;1\n\n\n对象\n0002\n李四\n2000\n10&#x2F;1\n\n\n对象\n0003\n王五\n3000\n11&#x2F;1\n\n\n类对应表格的结构，对象对应表格的内容\n一行数据对应一个对象，而表头（表结构）则对应的是类\n如果未来要学习数据库，数据库，就是一张张的表，在一张张表中调用和存储数据就是对对象和类的应用\n\n\n\n雇员表结构（类）\nClass Employee\n\n\n\nID\nint ID\n\n\nName\nString Name\n\n\nMoney\nString Money\n\n\nDate\nString Date\n\n\n晨会动作\nvoid kaichenhui(){}\n\n\n表格的动作和类的方法在类中定义成方法，即对每个对象都作用动态\n二、面向过程和面向对象思想联系1、面向对象和面向过程的区别面向过程：执行者思维，关注的是怎么实现\n对于一件事，首先考虑第一步干什么，第二步干什么，第三步……\n面向对象：对每一个对象操作\n假设要建一艘航母，一艘航母要由几百万甚至几亿个零件来构成，如果是面向过程，就要考虑对于建造航母，第一步该干什么，第二步该干什么，而操作对象仅为个体的零件，但如果是面向对象，我们首先考虑的就是如何设计这个事物，而不是按照步骤建造的问题，这之间的差别是思维模式的转变。\n比如，使用面向对象的思想来思考如何设计车\n天然的，我们就会从“车由什么组成”开始思考，发现车由以下对象构成\n\n轮胎\n发动机\n车壳\n座椅\n玻璃\n\n为了便于协作，去找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤……这样，大家可以同时进行汽车的制造，最终进行组装，大大提高了效率\n综上所述，面向对象可以帮助我们从宏观上把握，从整体上分析整个系统，但是具体到部分的微观操作仍然需要面向过程的思想去处理。\n面向对象和面向过程都是解决问题的思维方式，都是代码组织的方式。\n面向过程是一种执行者思维\n面向对象是一种设计者思维\n面向对象离不开面向过程：宏观上通过面向对象进行整体设计，微观上执行和处理数据，仍然是面向过程\n（简单的问题使用面向过程的思维方式就可以了，而复杂问题需要通过面向对象的组织思想）\n面向对象分析：写诗\n登鹳雀楼\n白日依山尽\n黄河入海流\n欲穷千里目\n更上一层楼\n\n外在场景：太阳，天空，黄河，河流交汇处，鹳雀楼，草\n诗人情怀：登高望远，进取，努力\n描述过程：由远及近，再到自身情怀\n可以用表格来表示以上信息\n\n\n\n物体\n物体类别\n别称（雅称）\n\n\n\n太阳\n实物\n金虎，赤乌，阳乌，朱雀……\n\n\n天空\n实物\n皇天，天宇，玉宇……\n\n\n黄河\n实物\n大河，母亲河，上河……\n\n\n草\n实物\n芦苇……\n\n\n鹳雀楼\n实物\n楼……\n\n\n登高望远\n虚物\n……\n\n\n进取\n虚物\n……\n\n\n努力\n虚物\n天天向上……\n\n\n完成以上Object以后，就需要进行组合，将这些Object融合到一个场景\n以上就是使用面向对象的思维来写的一首诗。\n面向对象分析：写小说对于一部小说，里面的场景，人物等等对象，都是事先构思好的，顺着大致的脉络一篇一篇往下写。\n三、对象和类的详解1，类和对象的概念在去认识一个事物的时候，肯定是去先去见一下实物，自己才能够再去抽象一种概念，一种理解。\n从认识的角度来理解，先有一个真实的物体，然后主观抽象出一个类，才能有这么一个对象。\n总结的过程就是抽象的过程\n类可以看作一个模板（表结构），或者图纸，系统根据类的定义来造出对象。\n类：我们叫做Class，对象：我们叫做Object，通常说某个类的对象，某个类的实例，是一样的意思。\n定义好类之后，一般会有三种常见的成员：属性，方法，构造器\n属性：定义该类或者该类对象所包含的数据或者说静态特征（也叫成员变量）\n方法：用于定义该类或者该类实例的行为特征或者功能实现（动态）\n构造器：也叫做构造方法，用于对象的初始化；\n构造器的四个要点\n\n构造器通过new关键字调用！\n构造器有返回值，但是不能定义返回值的类型，不能写返回值，不能return\n如果没有定义构造器，则编译器会构造一个无参数的构造器。\n构造器方法名必须和类名一致！\n\n2，内存分析内存模型\n\n线程：程序计数器，虚拟机栈，本地方法栈\n堆：新生代，老年代\n方法区：运行时常量池\n直接内存\n其他内存\n\n执行过程的内存分析\n通过内存分析更深刻的理解对象\nJava虚拟机内存模型概念\n线程分为程序计数器，虚拟机栈，本地方法栈。\n堆：创建的Java对象都在堆里面\n方法区：一种Java虚拟机的规范\n程序执行的内存分析过程（掌握）Java虚拟机分为：虚拟机栈，堆，方法区\n虚拟机栈\n栈描述的是方法执行的内存模型。每个方法会创建一个栈帧（存储局部变量，操作数，方法出口等。）\nJVM会为每个线程创造一个栈 \n栈属于私有，不能在线程之间共享\n栈的存储特性是“先进后出，后进先出”\n栈由系统自动分配，速度快，栈是一个连续的存储空间\n\n堆\n用于存储创建好的对象和数组（数组也是对象）\nJava只有一个堆，被所有线程共享\n堆是不连续的，分配灵活，速度慢\n\n方法区\n方法区是Java虚拟机规范，可以有不同实现\nJVM只有一个方法区，被所有线程共享\n方法区实际上也是堆，只是用于存储类，常量等相关信息\n用来存放程序中永远是不变或者唯一的内容\n\n3，垃圾回收机制内存管理：Java内存管理中很大程度指的就是：堆中对象的管理\n对象空间的分配：使用new关键字创建对象\n堆空间的释放\n垃圾回收算法：1，引用计数法，引用 次数达到上限后自动释放空间\n2，引用可达法（根搜索法）\n4，分代垃圾回收机制\n年轻代，所有新生成的对象首先放置Eden区，年轻代的目标尽可能尽快收集掉那些生命周期短的对象，年轻代区域放满对象后，就将对象存放到年老代区域\n年老代，年轻代中经历了N(默认15)次以后仍然存活，就会被放到年老代，属于生命周期较长的现象\n永久代，用于存放静态文件，如Java类，方法等。\n\nthis，static关键字this关键字对象创建的过程和this的本质创建一个对象：1，分配空间，初始化为0或Null，2，执行属性值显式初始化，3，执行构造方法，4，返回对象地址给相关变量\n this可以构造初始化方法，避免相同name\n","slug":"Java","date":"2024-01-21T08:53:49.000Z","categories_index":"编程","tags_index":"Java","author_index":"Ed-RYan"},{"id":"e20937b340b4576fb9a9923d14634252","title":"commonSoftware","content":"王兆淼王兆淼\n","slug":"commonSoftware","date":"2024-01-21T05:14:54.000Z","categories_index":"","tags_index":"","author_index":"Ed-RYan"},{"id":"8de2812c284cf8a360f926e81ed1f70d","title":"Multisim14.3安装教程","content":"一、下载链接Multisim14.3 下载链接：\n链接：https://pan.baidu.com/s/1JJyRK-RI0uWKtufmu9avgQ?pwd &#x3D; df20 提取码：df20 \n二、安装过程（傻瓜式安装过程）首先打开 setup 文件夹\n然后右键 Install.exe 文件，选择 以管理员身份运行。\n选择“我接受上述许可协议”(显而易见的)点击下一步\n采用默认选项，勾选“禁用 Windows 快速启动”后点击下一步\n继续点击下一步\n接着等待安装\n接着弹出 CircuitDesignSuite 的安装窗口，和刚刚一样，选择“我接受上述许可协议”点击下一步\n接着点击下一步\n接着是漫长的等待\n安装过程中会出现一个弹窗，注意要点击“否”\n安装完成，会自动提示你激活软件，这个时候点击取消\n还会提示你重启完成操作，这个时候不用重启，直接点击右上方的小叉叉关闭这个窗口\n接着回到刚刚解压目录下，打开解压的文件夹 Crack，里面是一个激活器，把它解压到当前文件夹（注意，解压这个文件的时候一定要关闭电脑上的所有杀毒软件，防火墙以及 WindowsDefender，否则该激活器可能会被杀毒软件误杀而导致激活失败）\n解压完成后，右键刚刚 Crack 文件夹解压的 NI License Activator 1.2, 以管理员身份运行，鼠标右键 Base Edition，选择 Activate，接着以同样的方法把下列选项全部 Activate，效果图如下\n接着打开刚刚解压的“汉化”文件夹，将 Chinese-simplified 文件夹复制\n接着是寻找你刚刚安装的 Multisim 软件的位置，可以点击桌面任务栏的开始图标，因为软件刚刚安装，Multisim 软件会列出在推荐项目中，点击右键，选择打开文件位置\n继续右键，选择打开文件所在位置\n这时候就来到了 Multisim 的安装目录，划到最上面，打开 stringfiles 文件夹\n右击空白处点击粘贴\n这个时候就安装成功了！可以从刚刚桌面任务栏处的开始图标点击 NI Multisim14.3 打开软件\n","slug":"Multisim","date":"2024-01-20T15:30:00.000Z","categories_index":"常用软件","tags_index":"教程","author_index":"Ed-RYan"},{"id":"1320fe65ed8f0eda865a406ac126c548","title":"Typora1.5.6中文版安装使用说明","content":"Typora是一款Markdown编辑器和查看器，主要用于创建和编辑Markdown格式的文档， 而Markdown文档可以轻松地转换为其他格式，如HTML、PDF、Word等。这种可移植性使得Markdown成为在不同平台和工具之间共享文档的不错选择，Typora是一个简便而强大的工具，下面给大家发放下载链接和安装教程。\n一、下载链接：Typora1.5.6下载链接：\n链接：https://pan.baidu.com/s/154gbZk8gY3OwIgiBLE-V8Q?pwd=7jyr 提取码：7jyr \n二、安装下载完成后解压压缩包，压缩包中有两个文件，一个是我们的Typora安装包，另一个是安装密码。\n解压后打开安装包，出现以下界面：\n\n输入我们的安装密码：12345678\n然后选择安装路径（建议安装到C盘以外的盘符）\n\n之后的选项都为默认选项\n安装结束后出现以下画面：\n\n点击Finish后安装结束。\n","slug":"Typora","date":"2024-01-20T15:30:00.000Z","categories_index":"常用软件","tags_index":"教程","author_index":"Ed-RYan"}]